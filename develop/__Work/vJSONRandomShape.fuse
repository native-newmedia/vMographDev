-- ============================================================================
-- modules
-- ============================================================================
local utf8 = require("utf8")
local chance = require("chance")
local customShapes = self and require("customShapes") or nil

-- ============================================================================
-- constants
-- ============================================================================
FUSE_NAME = "vJSONRandomShape"
DATATYPE = "ScriptVal"
DEFAULT_FONT_SIZE = 0.03
DEFAULT_FONT_NAME = "Open Sans"
DEFAULT_FONT_STYLE = "Regular"

-- ============================================================================
-- fuse registration
-- ============================================================================
FuRegisterClass(FUSE_NAME, CT_Tool, {
	REGID_DataType      = DATATYPE,
	REGID_InputDataType = DATATYPE,
	REGS_Category       = "Kartaverse\\Vonk Ultra\\Mograph\\JSON\\Shape",
	REGS_Name           = FUSE_NAME,
	REGS_OpDescription  = "Random shape and text generator with font support",
	REGS_IconID         = "Icons.Tools.Icons.sRender",
	REG_Version         = 200,
	REG_TimeVariant     = true,
	REGB_Temporal       = true,
	REG_Unpredictable   = true,
})

local ConnectionLabel = [[
<table align="center" cellspacing="8">
  <tr>
    <td style="text-align: center;"></td>
    <td style="text-align: center; background-color: #051626; color: white; padding: 5px; font-weight: bold;">[ ]] ..
	FUSE_NAME .. [[ ]</td>
    <td style="text-align: center;">  →  [ vJSONShapeRender Custom Shape ]</td>
  </tr>
</table>
]]

function Create()
	-- Connection label
	InLabelConnect = self:AddInput(ConnectionLabel, 'LabelConnect', {
		LINKID_DataType = 'Text',
		INPID_InputControl = 'LabelControl',
		LBLC_MultiLine = true,
		INP_External = false,
		INP_Passive = true,
		IC_ControlPage = -1,
		IC_NoLabel = true,
		IC_NoReset = true,
	})

	-- Generation mode selector
	InChanceOp = self:AddInput("Generate Random → ", "chanceOperation", {
		LINKID_DataType = "Number",
		INPID_InputControl = "ComboControl",
		IC_NoReset = true,
		INP_Default = 1,
		{ CCS_AddString = "None" },
		{ CCS_AddString = "Shapes" },
		{ CCS_AddString = "Character" },
		{ CCS_AddString = "Letter" },
		{ CCS_AddString = "Integer" },
		INP_DoNotifyChanged = true,
	})

	-- Shape type selector
	InShapeTypeSelector = self:AddInput("Shape Type", "shapetype", {
		LINKID_DataType = "Number",
		INPID_InputControl = "MultiButtonControl",
		INP_Default = 1,
		{ MBTNC_AddButton = "None", },
		{ MBTNC_AddButton = "Ticks", },
		{ MBTNC_AddButton = "Lines", },
		{ MBTNC_AddButton = "Frames", },
		{ MBTNC_AddButton = "Symbols", },
		{ MBTNC_AddButton = "Others", },
		INP_DoNotifyChanged = true,
	})

	-- Array controls
	InArrayLength = self:AddInput("Array length", "arrayLength", {
		LINKID_DataType = "Number",
		INPID_InputControl = "ScrewControl",
		INP_MinScale = 0,
		INP_MaxScale = 100,
		INP_Default = 2,
		INP_MinAllowed = 0,
		INP_MaxAllowed = 1e+38,
		INP_Integer = true,
	})

	InSeed = self:AddInput("Random Seed", "seed", {
		LINKID_DataType = "Number",
		INPID_InputControl = "CheckboxControl",
		INP_Default = 0,
	})

	-- Spacer
	InEmptySpace2 = self:AddInput('    ', 'EmptySpace2', {
		LINKID_DataType = 'Text',
		INPID_InputControl = 'LabelControl',
		ICD_Width = 0.3,
		INP_External = false,
		INP_Passive = true,
		IC_NoLabel = true,
		IC_NoReset = true,
	})

	-- Shape Settings
	self:BeginControlNest("Shape Settings", "shapesettings", false, {})

	InShapeScale = self:AddInput("Shape Scale", "ShapeScale", {
		LINKID_DataType = "Number",
		INPID_InputControl = "ScrewControl",
		INP_MinScale = 0.01,
		INP_MaxScale = 2.0,
		INP_Default = 0.05,
		INP_MinAllowed = 0.0,
	})

	InShapeRotation = self:AddInput("Shape Rotation", "ShapeRotation", {
		LINKID_DataType = "Number",
		INPID_InputControl = "ScrewControl",
		INP_MinScale = 0.0,
		INP_MaxScale = 360.0,
		INP_Default = 0.0,
	})

	self:EndControlNest()

	-- Text Settings
	self:BeginControlNest("Text Settings", "textsettings", false, {})

	InFontUse = self:AddInput("Font Select", "fontselect", {
		LINKID_DataType = "Number",
		INPID_InputControl = "MultiButtonControl",
		INP_Default = 0.0,
		{ MBTNC_AddButton = "Use Font",       MBTNCD_ButtonWidth = 1 / 2, },
		{ MBTNC_AddButton = "Use Font Array", MBTNCD_ButtonWidth = 1 / 2, },
		INP_Integer = true,
		INP_DoNotifyChanged = true,
	})

	InFont = self:AddInput("Font", "Font", {
		LINKID_DataType = "Text",
		INPID_InputControl = "FontFileControl",
		IC_ControlGroup = 2,
		IC_ControlID = 0,
		INP_Level = 1,
		INP_DoNotifyChanged = true,
	})

	InFontStyle = self:AddInput("Style", "Style", {
		LINKID_DataType = "Text",
		INPID_InputControl = "FontFileControl",
		IC_ControlGroup = 2,
		IC_ControlID = 1,
		INP_Level = 1,
		INP_DoNotifyChanged = true,
	})

	InSize = self:AddInput("Size", "Size", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_MinScale = 0.0,
		INP_MaxScale = 0.5,
		INP_Default = 0.08,
	})

	InCharacterSpacing = self:AddInput("Character Spacing", "Characterspacing", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_MinAllowed = -10,
		INP_MaxScale = 10.0,
		INP_Default = 0.0,
	})

	InCase = self:AddInput("Letter Case", "Case", {
		LINKID_DataType = "Number",
		INPID_InputControl = "MultiButtonControl",
		INP_Default = 0.0,
		{ MBTNC_AddButton = "NONE",  MBTNCD_ButtonWidth = 1 / 3, },
		{ MBTNC_AddButton = "UPPER", MBTNCD_ButtonWidth = 1 / 3, },
		{ MBTNC_AddButton = "LOWER", MBTNCD_ButtonWidth = 1 / 3, },
		INP_Integer = true,
	})

	InJustify = self:AddInput("Justification", "Justification", {
		LINKID_DataType = "Number",
		INPID_InputControl = "MultiButtonControl",
		INP_Default = 1.0,
		{ MBTNC_AddButton = "Left",   MBTNCD_ButtonWidth = 1 / 3, },
		{ MBTNC_AddButton = "Center", MBTNCD_ButtonWidth = 1 / 3, },
		{ MBTNC_AddButton = "Right",  MBTNCD_ButtonWidth = 1 / 3, },
		INP_Integer = true,
	})

	InHori_adjustment = self:AddInput("Horizontal Adjustment", "Hori_adjustment", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_MinScale = -0.5,
		INP_MaxScale = 0.5,
		INP_Default = 0.0,
		PC_ControlGroup = 1,
		PC_ControlID = 3,
	})

	InVer_adjustment = self:AddInput("Vertical Adjustment", "Ver_adjustment", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_MinScale = -0.5,
		INP_MaxScale = 0.5,
		INP_Default = 0.0,
		PC_ControlGroup = 1,
		PC_ControlID = 4,
	})

	InShowBackground = self:AddInput("Show Box Background", "ShowBackground", {
		LINKID_DataType = "Number",
		INPID_InputControl = "CheckboxControl",
		INP_Integer = true,
		INP_Default = 0.0,
		INP_External = false,
		INP_DoNotifyChanged = true
	})

	InBox_padding = self:AddInput("Box Padding", "Box_padding", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_MinScale = 0.0,
		INP_MaxScale = 1.0,
		INP_Default = 0.5,
	})

	InBox_adjustment = self:AddInput("Box Vertical Adjustment", "Box_Ver_adjustment", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_MinScale = 0.0,
		INP_MaxScale = 0.5,
		INP_Default = 0.0,
	})

	InBox_roundCorners = self:AddInput("Box Round Corners", "Box_roundCorners", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_MinScale = 0.0,
		INP_MaxScale = 0.1,
		INP_Default = 0.01,
	})

	InAdjustment = self:AddInput("Pos Adjustment", "pos_adjustment", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_MinScale = -1,
		INP_MaxScale = 1,
		INP_Default = 0.0,
	})

	self:EndControlNest()

	-- Input/Output controls
	InShowInput = self:AddInput("Show Input", "ShowInput", {
		LINKID_DataType = "Number",
		INPID_InputControl = "CheckboxControl",
		INP_Integer = true,
		INP_Default = 1.0,
		INP_External = false,
		INP_DoNotifyChanged = true
	})

	-- Data inputs
	InScriptValFont = self:AddInput("ScriptVal Font", "ScriptValFont", {
		LINKID_DataType = "ScriptVal",
		LINK_Main = 4,
	})

	InScriptValText = self:AddInput("ScriptVal Text", "ScriptValtext", {
		LINKID_DataType = "ScriptVal",
		LINK_Main = 2,
	})

	InText = self:AddInput("Text", "text", {
		LINKID_DataType = "Text",
		LINK_Main = 3,
	})

	-- Outputs
	OutScriptValShape = self:AddOutput("OutputValShape", "OutputValShape", {
		LINKID_DataType = DATATYPE,
		LINK_Main = 1
	})

	OutScriptValData = self:AddOutput("OutputValData", "OutputValData", {
		LINKID_DataType = DATATYPE,
	})
end

-- ============================================================================
-- UTF-8 Helper Functions
-- ============================================================================

-- Custom utf8.offset function
function utf8_offset(s, n)
	local pos = 1
	for i = 1, n - 1 do
		pos = pos + utf8_charbytes(s, pos)
	end
	return pos
end

-- Custom utf8.charbytes function
function utf8_charbytes(s, i)
	local c = string.byte(s, i)
	if c > 0 and c <= 127 then
		return 1
	elseif c >= 194 and c <= 223 then
		return 2
	elseif c >= 224 and c <= 239 then
		return 3
	elseif c >= 240 and c <= 244 then
		return 4
	end
end

-- Custom utf8.codepoint function
function utf8_codepoint(s, i)
	local c = string.byte(s, i)
	if c <= 127 then
		return c
	elseif c >= 194 and c <= 223 then
		local c2 = string.byte(s, i + 1)
		return (c - 192) * 64 + (c2 - 128)
	elseif c >= 224 and c <= 239 then
		local c2 = string.byte(s, i + 1)
		local c3 = string.byte(s, i + 2)
		return (c - 224) * 4096 + (c2 - 128) * 64 + (c3 - 128)
	elseif c >= 240 and c <= 244 then
		local c2 = string.byte(s, i + 1)
		local c3 = string.byte(s, i + 2)
		local c4 = string.byte(s, i + 3)
		return (c - 240) * 262144 + (c2 - 128) * 4096 + (c3 - 128) * 64 + (c4 - 128)
	end
end

-- ============================================================================
-- Font Management Functions
-- ============================================================================

-- Function to get a font based on probability
function getRandomFont(fontArray)
	-- Validate input
	if not fontArray or not fontArray.Fonts or #fontArray.Fonts == 0 then
		return nil
	end

	-- Count enabled fonts and normalize probabilities
	local enabledFonts = {}
	local totalProbability = 0

	for i, fontInfo in ipairs(fontArray.Fonts) do
		if fontInfo.Enabled then
			table.insert(enabledFonts, fontInfo)
			-- Default to equal probability if not specified
			fontInfo.Probability = fontInfo.Probability or (1 / fontArray.EnabledFontCount)
			totalProbability = totalProbability + fontInfo.Probability
		end
	end

	-- Return nil if no enabled fonts
	if #enabledFonts == 0 then
		return nil
	end

	-- Normalize probabilities if they don't sum to 1
	if math.abs(totalProbability - 1.0) > 0.001 then
		for _, fontInfo in ipairs(enabledFonts) do
			fontInfo.Probability = fontInfo.Probability / totalProbability
		end
	end

	-- Select a font based on probability
	local randomValue = math.random()
	local cumulativeProbability = 0

	for _, fontInfo in ipairs(enabledFonts) do
		cumulativeProbability = cumulativeProbability + fontInfo.Probability
		if randomValue <= cumulativeProbability then
			return fontInfo
		end
	end

	-- Fallback to first enabled font if something goes wrong
	return enabledFonts[1]
end

-- ============================================================================
-- Text Creation Function
-- ============================================================================

function createTextOptimized(text, fontArray, align, fontsize, char_spacing, hori_adjustment, ver_adjustment,
							 box_padding, box_adjustment, roundCorners, background, adjustment)
	-- Ensure text is a string
	if type(text) ~= "string" then
		text = tostring(text or "")
	end

	-- Safety checks
	if fontsize <= 0 then
		fontsize = DEFAULT_FONT_SIZE
	end

	-- Defensive: ensure fontArray is valid
	if not fontArray or not fontArray.Fonts or not fontArray.Fonts[1] then
		fontArray = {
			EnabledFontCount = 1,
			FontSize = DEFAULT_FONT_SIZE,
			Fonts = {
				{
					Index = 1,
					Size = DEFAULT_FONT_SIZE,
					Font = DEFAULT_FONT_NAME,
					Enabled = true,
					Style = DEFAULT_FONT_STYLE,
					Probability = 1,
				},
			},
			TotalFonts = 1
		}
	end

	local shape = Shape()
	local mat = Matrix4()
	local minX, minY, maxX, maxY = math.huge, math.huge, -math.huge, -math.huge

	local function updateBounds(point)
		if point.x < minX then minX = point.x end
		if point.y < minY then minY = point.y end
		if point.x > maxX then maxX = point.x end
		if point.y > maxY then maxY = point.y end
	end

	local function applyJustification(mat, justify, line_width)
		if justify == 1 then
			mat:Move(-line_width / 2, 0, 0)
		elseif justify == 2 then
			mat:Move(-line_width, 0, 0)
		end
	end

	-- Pre-calculate line heights for vertical positioning
	local lines = {}
	for line in string.gmatch(text, "[^\r\n]+") do
		table.insert(lines, line)
	end

	local total_height = 0
	local line_heights = {}

	-- Calculate total height using average metrics for estimation
	local refFontInfo = fontArray.Fonts[1]
	local refMetrics = TextStyleFont(refFontInfo.Font, refFontInfo.Style)
	local refTfm = TextStyleFontMetrics(refMetrics)
	local avg_line_height = (refTfm.TextAscent + refTfm.TextDescent + refTfm.TextExternalLeading) * 10 * fontsize

	for _ in ipairs(lines) do
		table.insert(line_heights, avg_line_height)
		total_height = total_height + avg_line_height
	end

	mat:Move(0, 0, 0)

	-- Process each line
	for line_idx, line in ipairs(lines) do
		local line_width = 0
		local char_positions = {}
		local char_fonts = {}
		local charWidth = {}

		-- First pass: calculate positions and select fonts for each character
		for i = 1, utf8.len(line) do
			-- Select a random font for this character
			local selectedFont = getRandomFont(fontArray)
			char_fonts[i] = selectedFont

			local fontMetrics = TextStyleFont(selectedFont.Font, selectedFont.Style)
			local tfm = TextStyleFontMetrics(fontMetrics)
			local size = fontsize

			local ch = utf8_codepoint(line, utf8_offset(line, i)) or utf8_codepoint(" ")
			charWidth[i] = tfm:CharacterWidth(ch) * (10 + char_spacing) * size

			char_positions[i] = {
				width = charWidth[i],
				tfm = tfm,
				size = size,
				cp = ch
			}

			line_width = line_width + charWidth[i]
		end

		-- Apply justification for this line
		applyJustification(mat, align, line_width)

		-- Second pass: render each character with its selected font
		local x_move = 0

		for i = 1, utf8.len(line) do
			local char_info = char_positions[i]
			local fontInfo = char_fonts[i]
			local ch = char_info.cp
			local cw = char_info.width
			local tfm = char_info.tfm
			local size = char_info.size

			-- Calculate kerning if not the first character
			if i > 1 then
				local prev_char = char_positions[i - 1]
				local kerning = tfm:CharacterKerning(prev_char.cp, ch) * (10 + char_spacing) * size
				x_move = x_move + kerning
				mat:Move(kerning, 0, 0)
			end

			mat:Move(cw / 2, 0, 0)

			if ch ~= 32 then -- Skip spaces
				local char_mat = Matrix4(mat)
				char_mat:Scale((1.0 / tfm.Scale) * size, (1.0 / tfm.Scale) * size, 1.0)
				char_mat:Move(x_move + (cw / 2), 0, 0)

				local sh = tfm:GetCharacterShape(ch, false):TransformOfShape(char_mat)
				shape:AddShape(sh)

				local transformedPoint = Vector4(0, 0, 0, 1) * mat
				updateBounds(transformedPoint)
			end

			mat:Move(cw / 2, 0, 0)
			x_move = x_move + cw
		end

		-- Move to next line
		mat:Move(-x_move, 0, 0)
		shape = shape:TransformOfShape(mat)
		mat:Move(-x_move, -line_heights[line_idx], 0)
	end

	-- Create background if needed
	local padding = box_padding * fontsize
	local rect = Shape()

	if background == 1 then
		rect:AddRectangle(minX - padding, maxX + padding, minY - padding, maxY + padding, roundCorners, 8)
	end

	local height_adjustment = (-(maxY + padding) / 2) + box_adjustment

	mat:Identity()
	mat:Move(0, height_adjustment, 0)
	mat:Move(hori_adjustment, ver_adjustment, 0)
	shape = shape:TransformOfShape(mat)

	mat:Identity()
	mat:Move(0, 0, 0)
	rect = rect:TransformOfShape(mat)

	local shapeTable = { rect, shape }
	return shapeTable
end

-- ============================================================================
-- Custom Shape Creation Function
-- ============================================================================
function shuffle(array)
	for i = #array, 2, -1 do
		local j = math.random(i)          -- random index between 1 and i
		array[i], array[j] = array[j], array[i] -- swap
	end
end

function createCustomShape(type_Selector, shapeScale, shapeRotation)
	-- Safety checks
	if not customShapes then
		return {}
	end

	-- Function to copy every nth element from a table starting from a specific position
	local function copyNthElements(tbl, interval, startpos)
		local result = {}
		for k = startpos, #tbl, interval do
			table.insert(result, tbl[k])
		end
		return result
	end

	-- Select the appropriate shape array based on type_Selector
	local shapeArrays = {
		customShapes:ticks(),
		customShapes:lines(),
		customShapes:frames(),
		customShapes:symbols(),
		customShapes:others()
	}

	-- Ensure type_Selector is within bounds
	if type_Selector + 1 < 1 or type_Selector + 1 > #shapeArrays then
		return {}
	end

	local mainShapeArray = shapeArrays[type_Selector + 1] or {}
	if #mainShapeArray == 0 then
		return {}
	end

	local mainShapeGroup = {}


	-- Add all shapes from the selected mainShapeArray to mainShapeGroup
	for d = 1, #mainShapeArray do
		table.insert(mainShapeGroup, mainShapeArray[d])
	end

	local mainShapeGroup_X = {}


	for i = 1, #mainShapeGroup do
		for d = 1, #mainShapeArray[i] do
			local shapeData = mainShapeArray[i][d]
			local shape = Shape()

			local Shapes_X = copyNthElements(shapeData, 2, 1)
			local Shapes_Y = copyNthElements(shapeData, 2, 0)
			local numShapes = #Shapes_X

			if numShapes > 0 then
				shape:MoveTo(Shapes_X[1] / 1000, Shapes_Y[1] / 1000)
				for j = 2, numShapes do
					shape:LineTo(Shapes_X[j] / 1000, Shapes_Y[j] / 1000)
				end
				shape:Close()

				local mat = Matrix4()
				mat:Identity()
				mat:Move(0, 0, 0)
				mat:Scale(shapeScale, shapeScale, 1)
				mat:RotZ(shapeRotation)

				shape = shape:TransformOfShape(mat)
				table.insert(mainShapeGroup_X, shape)
			end
		end
	end
	return mainShapeGroup_X
end

-- ============================================================================
-- Utility: Shuffle array using seeded random
function shuffleArray(arr)
	for i = #arr, 2, -1 do
		local j = chance.integer({ min = 1, max = i })
		arr[i], arr[j] = arr[j], arr[i]
	end
	return arr
end

-- ============================================================================
-- Main Processing Function
-- ============================================================================

function Process(req)
	-- Get input values
	local font           = InFont:GetValue(req).Value
	local style          = InFontStyle:GetValue(req).Value
	local fontUse        = InFontUse:GetValue(req).Value
	local size           = InSize:GetValue(req).Value
	local justify        = InJustify:GetValue(req).Value
	local hori_adjust    = InHori_adjustment:GetValue(req).Value
	local ver_adjust     = InVer_adjustment:GetValue(req).Value
	local box_padding    = InBox_padding:GetValue(req).Value
	local box_adjustment = InBox_adjustment:GetValue(req).Value
	local roundCorners   = InBox_roundCorners:GetValue(req).Value
	local char_spacing   = InCharacterSpacing:GetValue(req).Value
	local arrLength      = InArrayLength:GetValue(req).Value
	local seed           = InSeed:GetValue(req).Value
	local mode           = InChanceOp:GetValue(req).Value
	local shapeSelector  = InShapeTypeSelector:GetValue(req).Value
	local shapeScale     = InShapeScale:GetValue(req).Value
	local shapeRotation  = InShapeRotation:GetValue(req).Value
	local textItem       = InText:GetValue(req).Value
	local text           = InScriptValText:GetValue(req):GetValue() or {}

	-- Initialize arrays
	local result         = {}
	local outputShape    = {}
	local outputData     = {}

	-- Initialize font manager if needed
	if not next(FontManager:GetFontList()) then
		FontManager:ScanDir()
	end

	-- Seed the random number generator
	chance:seed(seed)

	-- Generate random values based on the selected mode
	local function generateRandomValue(mode)
		if mode == 0 then
			return nil
		elseif mode == 1 then
			return createCustomShape(shapeSelector - 1, shapeScale, shapeRotation)
		elseif mode == 2 then
			return tostring(chance:character())
		elseif mode == 3 then
			return tostring(chance:letter())
		elseif mode == 4 then
			return tostring(chance:integer())
		end
	end

	-- Optimized array management without while loops
	if mode == 0 then
		-- Clear and create new table with nils
		result = {}
		for i = 1, arrLength do
			result[i] = nil
		end
	elseif mode == 1 then
		local baseResult = generateRandomValue(1)

		-- Ensure baseResult is a table
		if type(baseResult) ~= "table" then
			baseResult = { baseResult }
		end

		result = {}
		local baseLength = #baseResult

		if baseLength > 0 then
			-- Fill result to exact arrLength by repeating pattern
			for i = 1, arrLength do
				local sourceIndex = ((i - 1) % baseLength) + 1
				result[i] = baseResult[sourceIndex]
			end
		else
			-- Fallback if baseResult is empty
			for i = 1, arrLength do
				result[i] = nil
			end
		end
	else
		-- Generate exact number of random values
		result = {}
		for i = 1, arrLength do
			result[i] = generateRandomValue(mode)
		end
	end

	-- Set up font array
	local default_fontArray = {
		EnabledFontCount = 1,
		FontSize = DEFAULT_FONT_SIZE,
		Fonts = {
			{
				Index = 1,
				Size = DEFAULT_FONT_SIZE,
				Font = font or DEFAULT_FONT_NAME,
				Enabled = true,
				Style = style or DEFAULT_FONT_STYLE,
				Probability = 1,
			},
		},
		TotalFonts = 1
	}

	local array_str_shape = InScriptValFont:GetValue(req):GetValue() or {}
	local fontArray = {}

	if array_str_shape and array_str_shape ~= "" then
		local inp_shape_tbl = array_str_shape
		if inp_shape_tbl ~= nil and type(inp_shape_tbl) == "table" then
			fontArray = inp_shape_tbl
		else
			fontArray = default_fontArray
		end
	else
		fontArray = default_fontArray
	end

	-- Handle font selection logic
	local function isValidFontArray(arr)
		return arr and arr.Fonts and #arr.Fonts > 0
	end

	if fontUse == 1 then
		if not isValidFontArray(fontArray) then
			fontArray = default_fontArray
		end
	elseif fontUse == 0 then
		fontArray = default_fontArray
	end

	-- Process each result item
	local case = InCase:GetValue(req).Value

	if InSeed:GetValue(req).Value < 1 then
		result = result
	else
		result = shuffleArray(result)
	end

	for i = 1, #result do
		local modified_text = result[i]

		-- Apply case transformation
		if case == 1 then
			modified_text = utf8.upper(modified_text)
		elseif case == 2 then
			modified_text = utf8.lower(modified_text)
		end
		-- Note: case == 0 doesn't need explicit handling since modified_text is already correct

		table.insert(outputData, i, modified_text)

		if mode == 1 then
			-- Directly use the custom shape for mode 1
			table.insert(outputShape, i, modified_text)
		else
			table.insert(outputShape, i,
				createTextOptimized(modified_text, fontArray, justify, size, char_spacing, hori_adjust, ver_adjust,
					box_padding, box_adjustment, roundCorners, InShowBackground:GetValue(req).Value,
					InAdjustment:GetValue(req).Value))
		end
	end

	OutScriptValShape:Set(req, ScriptValParam(outputShape))
end

-- ============================================================================
-- Notification Handler
-- ============================================================================

function NotifyChanged(inp, param, time)
	if inp == InFontUse then
		if param.Value < 0.5 then
			InFontStyle:SetAttrs({ PC_Visible = true, IC_Visible = true })
			InFont:SetAttrs({ PC_Visible = true, IC_Visible = true })
		else
			InFontStyle:SetAttrs({ PC_Visible = false, IC_Visible = false })
			InFont:SetAttrs({ PC_Visible = false, IC_Visible = false })
		end
	end

	if inp == InFont then
		local f = param.Value
		if f == nil or string.len(f) == 0 then
			InFont:SetSource(Text(DEFAULT_FONT_NAME), time)
		end
	elseif inp == InFontStyle then
		local f = param.Value
		if f == nil or string.len(f) == 0 then
			InFontStyle:SetSource(Text(DEFAULT_FONT_STYLE), time)
		end
	end

	if inp == InChanceOp then
		local f = param.Value
		if f == 1 then
			InShapeTypeSelector:SetAttrs({ PC_Visible = true, IC_Visible = true })
		elseif f >= 2 then
			InShapeTypeSelector:SetAttrs({ PC_Visible = false, IC_Visible = false })
		end
	end

	if inp == InShowInput then
		if param.Value == 1.0 then
			visible = true
		else
			visible = false
		end
	end
end
