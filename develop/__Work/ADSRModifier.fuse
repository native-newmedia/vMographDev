-- =========================================================================
-- modules
-- =========================================================================

-- =========================================================================
-- constants
-- =========================================================================
FUSE_NAME = "ADSRModifier"
DATATYPE  = "Image"

-- =========================================================================
-- fuse registration
-- =========================================================================
FuRegisterClass(FUSE_NAME, CT_Tool, {
    REGS_Category      = "Kartaverse\\Vonk Ultra\\Mograph\\__dev",
    REGS_Name          = FUSE_NAME,
    REGS_OpIconString  = FUSE_NAME,
    REGS_OpDescription = "Audio Envelope Modifier (from WAV file)",
    REG_TimeVariant    = true,
    REG_Unpredictable  = true,
    REGS_IconID        = "Icons.Tools.Icons.StickyNote",
    REG_Version        = 100,
})

local ConnectionLabel = [[
<table align="center" cellspacing="8">
  <tr>
    <td style="text-align: center;">[Map Dot Y Pos]  → </td>
    <td style="text-align: center; background-color: #051626; color: white; padding: 5px; font-weight: bold;">[ ]] ..
    FUSE_NAME .. [[ ]</td>
    <td style="text-align: center;">  → [ Mapped Value ]</td>
  </tr>
</table>
]]
function Create()
    -- [[ Creates the user interface. ]]

    InFPS              = self and InFPS or self:AddInput("FPS", "FPS", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 24,
        INP_MinScale = 1,
        INP_MaxScale = 120,
    })

    InMaxAmplitude     = self:AddInput("Max Amplitude", "MaxAmplitude", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 1.0,
        INP_MinScale = 0.0001,
        INP_MaxScale = 5.0,
        INP_MinAllowed = 0.0001,

    })

    Inline1Separator_1 = self:AddInput("line1Separator", "line1Separator_1", {
        INPID_InputControl = "SeparatorControl",
        IC_Visible = true,
        INP_External = false,
    })

    InAttack           = self:AddInput("Attack (ms)", "Attack", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 50.0,
        INP_MinScale = 0.0,
        INP_MaxScale = 1000.0,
    })
    InDecay            = self:AddInput("Decay (ms)", "Decay", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.1,
        INP_MinScale = 0.0,
        INP_MaxScale = 2.0,
    })

    InSustain          = self:AddInput("Sustain (ms)", "Sustain", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.5,
        INP_MinScale = 0.0,
        INP_MaxScale = 5.0,
    })

    InRelease          = self:AddInput("Release (ms)", "Release", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 300.0,
        INP_MinScale = 0.0,
        INP_MaxScale = 2000.0,
    })

    Inline1Separator_2 = self:AddInput("line1Separator", "line1Separator_2", {
        INPID_InputControl = "SeparatorControl",
        IC_Visible = true,
        INP_External = false,
    })
    InLabelConnect     = self:AddInput(ConnectionLabel, 'LabelConnect', {
        LINKID_DataType = 'Text',
        INPID_InputControl = 'LabelControl',
        LBLC_MultiLine = true,
        INP_External = false,
        INP_Passive = true,
        IC_NoLabel = true,
        IC_NoReset = true,
    })

    InMapMin           = self:AddInput("Map Min", "MapMin", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0,
        INP_MinScale = -2000.0,
        INP_MaxScale = 2000.0,
    })
    InMapMax           = self:AddInput("Map Max", "MapMax", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 1,
        INP_MinScale = -2000.0,
        INP_MaxScale = 2000.0,
    })

    Inline1Separator_3 = self:AddInput("line1Separator", "line1Separator_3", {
        INPID_InputControl = "SeparatorControl",
        IC_Visible = true,
        INP_External = false,
    })

    InDotSpeed         = self:AddInput("Dot Speed", "Speed", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Default = 0.02,
        INP_MinScale = 0.001,
        INP_MaxScale = 0.2,
    })
    InDotSize          = self:AddInput("Dot Size", "Dotsize", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Default = 0.02,
        INP_MinScale = 0.001,
        INP_MaxScale = 0.2,
    })

    InStrokesize       = self:AddInput("Stroke Size", "Strokesize", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Default = 0.01,
        INP_MinScale = 0.001,
        INP_MaxScale = 0.5,
    })
    Inline1Separator_4 = self:AddInput("line1Separator", "line1Separator_4", {
        INPID_InputControl = "SeparatorControl",
        IC_Visible = true,
        INP_External = false,
    })

    InShapeScale       = self:AddInput("ADSR Shape Scale", "shapescale", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 1.0,
        INP_MinScale = 0.0,
        INP_MaxScale = 1.0,
    })
    InCenter           = self:AddInput("ADSR Shape Position", "center", {
        LINKID_DataType      = "Point",
        INPID_InputControl   = "OffsetControl",
        INPID_PreviewControl = "CrosshairControl",
        INP_Disabled         = false,
        INP_DefaultY         = 0.0,
        INP_DefaultX         = 0.0,
        IC_Visible           = true,
        PC_Visible           = true
    })
    InShowShape        = self:AddInput("Show ADSR Shape", "ShowShape", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 1.0,
        INP_DoNotifyChanged = true,
    })

    InImage            = self:AddInput("Input", "Input", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
    })
    OutValue           = self:AddOutput("Envelope Output", "Value", {
        LINKID_DataType = "Number",
        LINK_Main = 3,
    })

    OutScriptVal       = self:AddOutput("ScriptVal Export", "ScriptVal", {
        LINKID_DataType = "ScriptVal",
        LINK_Main = 2,
    })
    OutImage           = self:AddOutput("Output", "Output", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
    })
end

function NotifyChanged(inp, param, time)
    if inp == InShowShape then
        if param.Value == 1 then
            InCenter:SetAttrs({ IC_Visible = true, PC_Visible = true })
        else
            InCenter:SetAttrs({ IC_Visible = false, PC_Visible = false })
        end
    end
end

local dotYpos = 0

-- Shape rendering
function CreateADSRShape(ic, attack, decay, sustain, release, maxAmplitude, currentTime, shapeScale, cx, cy,
                         dotSize, showShape, strokesize)
    local segments = {
        { 0,                        0,                  attack,                             maxAmplitude,       1,   0, 1 },
        { attack,                   maxAmplitude,       attack + decay,                     maxAmplitude * 0.7, 1,   0, 0 },
        { attack + decay,           maxAmplitude * 0.7, attack + decay + sustain,           maxAmplitude * 0.7, 0,   1, 0 },
        { attack + decay + sustain, maxAmplitude * 0.7, attack + decay + sustain + release, 0,                  0.5, 0, 1 },
    }

    local cs = ChannelStyle()
    local mat = Matrix4()
    mat:Identity()
    mat:Scale(0.5, 0.5, 1.0)

    mat:Scale(shapeScale, shapeScale, 1.0)
    mat:Move(cx, cy, 1.0)

    -- TODO: Add smoothing to the corners

    if showShape == 1 then
        for _, seg in ipairs(segments) do
            local sh = Shape()
            sh:MoveTo(seg[1], seg[2])
            sh:LineTo(seg[3], seg[4])
            sh = sh:OutlineOfShape(strokesize, "OLT_Solid", "OJT_Round", 8, "SWM_Normal", 8)
            ic:ShapeFill(sh:TransformOfShape(mat))

            cs.Color = Pixel { R = seg[5], G = seg[6], B = seg[7], A = 1 }
            ic:PutToImage("CM_Merge", cs)
        end

        local dotX, dotY = 0, 0
        for _, seg in ipairs(segments) do
            if currentTime >= seg[1] and currentTime <= seg[3] then
                local t = (currentTime - seg[1]) / (seg[3] - seg[1])
                dotX = currentTime
                dotY = seg[2] + (seg[4] - seg[2]) * t
                dotYpos = dotY
                break
            end
        end

        local shDot = createCircleShape(dotX, dotY, dotSize)
        ic:ShapeFill(shDot:TransformOfShape(mat))

        cs.Color = Pixel { R = 1, G = 1, B = 1, A = 1 }
        ic:PutToImage("CM_Merge", cs)
    end
end

-- Shape Creation Functions
function createCircleShape(x, y, radius)
    local shape = Shape()
    local segments = 16

    shape:MoveTo(x + radius, y)
    for i = 1, segments do
        local angle = (i / segments) * 2 * math.pi
        shape:LineTo(x + math.cos(angle) * radius, y + math.sin(angle) * radius)
    end
    shape:Close()

    return shape
end

function convertY(y, ref_img)
    return y * (ref_img.Height * ref_img.YScale) / (ref_img.Width * ref_img.XScale)
end

-- Maps a value from [in_min, in_max] to [out_min, out_max]
function map(value, in_min, in_max, out_min, out_max)
    return (value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min
end

function Process(req)
    local img           = InImage:GetValue(req)
    local out           = img:CopyOf()

    local position      = InCenter:GetValue(req)
    local cx            = position.X
    local cy            = convertY(position.Y, img)
    local shapeScale    = InShapeScale:GetValue(req).Value
    local mapMin        = InMapMin:GetValue(req).Value
    local mapMax        = InMapMax:GetValue(req).Value

    local frame         = req.Time

    local fps           = InFPS:GetValue(req).Value
    local speed         = InDotSpeed:GetValue(req).Value
    local t             = (frame / fps) * speed

    local totalDuration = InAttack:GetValue(req).Value / 1000
        + InDecay:GetValue(req).Value
        + InSustain:GetValue(req).Value
        + InRelease:GetValue(req).Value / 1000

    local mappedDotYpos = map(dotYpos, 0, InMaxAmplitude:GetValue(req).Value, mapMin, mapMax)
    OutValue:Set(req, mappedDotYpos)

    local ic = ImageChannel(out, 8)
    local cs = ChannelStyle()
    local mat = Matrix4()

    --Shape Rendering

    -- TODO: Add smoothing to the corners

    CreateADSRShape(ic,
        InAttack:GetValue(req).Value / 1000,
        InDecay:GetValue(req).Value,
        InSustain:GetValue(req).Value,
        InRelease:GetValue(req).Value / 1000,
        InMaxAmplitude:GetValue(req).Value,
        (frame / fps) * speed,
        shapeScale, cx, cy,
        InDotSize:GetValue(req).Value,
        InShowShape:GetValue(req).Value,
        InStrokesize:GetValue(req).Value
    )

    local attack  = InAttack:GetValue(req).Value / 1000
    local decay   = InDecay:GetValue(req).Value
    local sustain = InSustain:GetValue(req).Value
    local release = InRelease:GetValue(req).Value / 1000

    local phase   = ""
    if t < attack then
        phase = "Attack"
    elseif t < attack + decay then
        phase = "Decay"
    elseif t < attack + decay + sustain then
        phase = "Sustain"
    elseif t < attack + decay + sustain + release then
        phase = "Release"
    else
        phase = "Finished"
    end

    local envTable = {
        phase = phase,
        time = t,
        attack = attack,
        decay = decay,
        sustain = sustain,
        release = release,
        dotYpos = dotYpos,
        mappedDotYpos = mappedDotYpos
    }

    OutScriptVal:Set(req, ScriptValParam(envTable))
    OutImage:Set(req, out)
end
