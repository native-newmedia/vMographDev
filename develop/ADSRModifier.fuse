-- =========================================================================
-- modules
-- =========================================================================
local audio     = require("audio_modifier")
local jsonutils = self and require("vjsonutils") or nil
local json      = require("dkjson")

-- =========================================================================
-- constants
-- =========================================================================
FUSE_NAME       = "ADSRModifier"
DATATYPE        = "Image"

-- =========================================================================
-- fuse registration
-- =========================================================================
FuRegisterClass(FUSE_NAME, CT_Tool, {
    REGS_Category      = "Kartaverse\\Vonk Ultra\\Mograph\\__dev",
    REGS_Name          = FUSE_NAME,
    REGS_OpIconString  = FUSE_NAME,
    REGS_OpDescription = "Audio Envelope Modifier (from WAV file)",
    REG_TimeVariant    = true,
    REG_Unpredictable  = true,
    REGS_IconID        = "Icons.Tools.Icons.StickyNote",
    REG_Version        = 100,
})

function Create()

    InFPS          = self and InFPS or self:AddInput("FPS", "FPS", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 24,
        INP_MinScale = 1,
        INP_MaxScale = 120,
    })

    InMaxAmplitude = self:AddInput("Max Amplitude", "MaxAmplitude", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 1.0,
        INP_MinScale = 0.1,
        INP_MaxScale = 5.0,
    })

    Inline1Separator_1 = self:AddInput("line1Separator", "line1Separator_1", {
        INPID_InputControl = "SeparatorControl",
        IC_Visible = true,
        INP_External = false,
    })

    InAttack       = self:AddInput("Attack (ms)", "Attack", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 50.0,
        INP_MinScale = 0.0,
        INP_MaxScale = 1000.0,
    })
    InDecay        = self:AddInput("Decay (ms)", "Decay", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.1,
        INP_MinScale = 0.0,
        INP_MaxScale = 2.0,
    })

    InSustain      = self:AddInput("Sustain (ms)", "Sustain", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.5,
        INP_MinScale = 0.0,
        INP_MaxScale = 5.0,
    })

    InRelease      = self:AddInput("Release (ms)", "Release", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 300.0,
        INP_MinScale = 0.0,
        INP_MaxScale = 2000.0,
    })

    Inline1Separator_2 = self:AddInput("line1Separator", "line1Separator_2", {
        INPID_InputControl = "SeparatorControl",
        IC_Visible = true,
        INP_External = false,
    })



    InTotalTime    = self:AddInput("Total Time (s)", "TotalTime", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 4.0,
        INP_MinScale = 0.1,
        INP_MaxScale = 10.0,
    })

    Inline1Separator_3 = self:AddInput("line1Separator", "line1Separator_3", {
        INPID_InputControl = "SeparatorControl",
        IC_Visible = true,
        INP_External = false,
    })



    InDotSpeed = self:AddInput("Dot Speed", "Speed", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Default = 0.02,
        INP_MinScale = 0.001,
        INP_MaxScale = 0.2,
    })
    InDotSize = self:AddInput("Dot Size", "Dotsize", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Default = 0.02,
        INP_MinScale = 0.001,
        INP_MaxScale = 0.2,
    })

    Inline1Separator_4 = self:AddInput("line1Separator", "line1Separator_4", {
        INPID_InputControl = "SeparatorControl",
        IC_Visible = true,
        INP_External = false,
    })

    InShapeScale = self:AddInput("ADSR Shape Scale", "shapescale", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 1.0,
        INP_MinScale = 0.0,
        INP_MaxScale = 1.0,
    })
    InCenter = self:AddInput("ADSR Shape Position", "center", {
        LINKID_DataType      = "Point",
        INPID_InputControl   = "OffsetControl",
        INPID_PreviewControl = "CrosshairControl",
        INP_Disabled         = false,
        INP_DefaultY         = 0.0,
        INP_DefaultX         = 0.0,
        IC_Visible           = true,
        PC_Visible           = true
    })
    InShowShape = self:AddInput("Show ADSR Shape", "ShowShape", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0.0,
        INP_DoNotifyChanged = true,
    })




    InImage = self:AddInput("Input", "Input", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
    })
    OutValue = self:AddOutput("Envelope Output", "Value", {
        LINKID_DataType = "Number",
        LINK_Main = 3,
    })

    OutScriptVal = self:AddOutput("ScriptVal Export", "ScriptVal", {
        LINKID_DataType = "ScriptVal",
        LINK_Main = 2,
    })
    OutImage = self:AddOutput("Output", "Output", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
    })
end


function NotifyChanged(inp, param, time)

     if inp == InShowShape then

         if param.Value == 1 then
        
        InCenter:SetAttrs({ IC_Visible = true, PC_Visible = true })
    else
         InCenter:SetAttrs({ IC_Visible = false, PC_Visible = false })
     end

 end

end


local dotYpos = 0

-- Shape rendering
function CreateADSRShape(ic, attack, decay, sustain, release, maxAmplitude, totalTime, currentTime, shapeScale, cx, cy,dotSize,showShape)
    local segments = {
        { 0,                        0,                  attack,                             maxAmplitude,       1,   0, 1 },
        { attack,                   maxAmplitude,       attack + decay,                     maxAmplitude * 0.7, 1,   0, 0 },
        { attack + decay,           maxAmplitude * 0.7, attack + decay + sustain,           maxAmplitude * 0.7, 0,   1, 0 },
        { attack + decay + sustain, maxAmplitude * 0.7, attack + decay + sustain + release, 0,                  0.5, 0, 1 },
    }

    local cs = ChannelStyle()
    local mat = Matrix4()
    mat:Identity()
    mat:Scale(0.5, 0.5, 1.0)

    mat:Scale(shapeScale, shapeScale, 1.0)
    mat:Move(cx, cy, 1.0)

    -- TODO: Add smoothing to the corners

if showShape == 1 then
    for _, seg in ipairs(segments) do
        local sh = Shape()
        sh:MoveTo(seg[1], seg[2])
        sh:LineTo(seg[3], seg[4])
        sh = sh:OutlineOfShape(0.01, "OLT_Solid", "OJT_Round", 8, "SWM_Normal", 8)
        ic:ShapeFill(sh:TransformOfShape(mat))


        cs.Color = Pixel { R = seg[5], G = seg[6], B = seg[7], A = 1 }
        ic:PutToImage("CM_Merge", cs)
    end

    local dotX, dotY = 0, 0
    for _, seg in ipairs(segments) do
        if currentTime >= seg[1] and currentTime <= seg[3] then
            local t = (currentTime - seg[1]) / (seg[3] - seg[1])
            dotX = currentTime
            dotY = seg[2] + (seg[4] - seg[2]) * t
            dotYpos=dotY
            break
        end
    end


    
    local shDot = createCircleShape(dotX, dotY, dotSize)
    ic:ShapeFill(shDot:TransformOfShape(mat))
    
    cs.Color = Pixel { R = 0, G = 0, B = 1, A = 1 }
    ic:PutToImage("CM_Merge", cs)
    end
end

-- Shape Creation Functions
function createCircleShape(x, y, radius)
    local shape = Shape()
    local segments = 16

    shape:MoveTo(x + radius, y)
    for i = 1, segments do
        local angle = (i / segments) * 2 * math.pi
        shape:LineTo(x + math.cos(angle) * radius, y + math.sin(angle) * radius)
    end
    shape:Close()

    return shape
end

function createSquareShape(x, y, size)
    local shape = Shape()
    local half = size / 2
    shape:AddRectangle(x - half, x + half, y - half, y + half, 0, 8)
    return shape
end

function createTriangleShape(x, y, size)
    local shape = Shape()
    local height = size * 0.866 -- equilateral triangle height

    shape:MoveTo(x, y + height / 2)
    shape:LineTo(x - size / 2, y - height / 2)
    shape:LineTo(x + size / 2, y - height / 2)
    shape:Close()

    return shape
end

function convertY(y, ref_img)
    return y * (ref_img.Height * ref_img.YScale) / (ref_img.Width * ref_img.XScale)
end

function Process(req)
    local img        = InImage:GetValue(req)
    local out        = img:CopyOf()


    local position   = InCenter:GetValue(req)
    local cx         = position.X
    local cy         = convertY(position.Y, img)
    local shapeScale = InShapeScale:GetValue(req).Value


    local frame         = req.Time

    local fps           = InFPS:GetValue(req).Value
    local speed         = InDotSpeed:GetValue(req).Value
    local t             = (frame / fps) * speed

    local totalDuration = InAttack:GetValue(req).Value / 1000
        + InDecay:GetValue(req).Value
        + InSustain:GetValue(req).Value
        + InRelease:GetValue(req).Value / 1000


    OutValue:Set(req, dotYpos)

    local ic = ImageChannel(out, 8)
    local fs = FillStyle()
    local cs = ChannelStyle()

    local mat = Matrix4()


    --Shape Rendering

    -- TODO: Add smoothing to the corners

    CreateADSRShape(ic,
        InAttack:GetValue(req).Value / 1000,
        InDecay:GetValue(req).Value,
        InSustain:GetValue(req).Value,
        InRelease:GetValue(req).Value / 1000,
        InMaxAmplitude:GetValue(req).Value,
        InTotalTime:GetValue(req).Value,
        (frame / fps) * speed,
        shapeScale, cx, cy,
        InDotSize:GetValue(req).Value,
        InShowShape:GetValue(req).Value
    )

 

    local attack  = InAttack:GetValue(req).Value / 1000
    local decay   = InDecay:GetValue(req).Value
    local sustain = InSustain:GetValue(req).Value
    local release = InRelease:GetValue(req).Value / 1000

    local phase   = ""
    if t < attack then
        phase = "Attack"
    elseif t < attack + decay then
        phase = "Decay"
    elseif t < attack + decay + sustain then
        phase = "Sustain"
    elseif t < attack + decay + sustain + release then
        phase = "Release"
    else
        phase = "Finished"
    end

    local envTable = {
        phase = phase,
       -- value = env,
        time = t,
        attack = attack,
        decay = decay,
        sustain = sustain,
        release = release,
        dotYpos=dotYpos,
    }

    OutScriptVal:Set(req, ScriptValParam(envTable))
    OutImage:Set(req, out)
   
end
