--[[--
CircuitBoard.fuse
Abstract Circuit Board Generator for DaVinci Resolve Fusion
Generates procedural circuit board patterns with customizable nodes and traces
--]] --

FuRegisterClass("CircuitBoard", CT_Tool, {
    REGS_Category      = "Kartaverse\\Vonk Ultra\\Mograph\\__dev",
    REGS_OpIconString  = "Cir",
    REGS_OpDescription = "Abstract Circuit Board Generator",
})

function Create()
    -- Pattern Type Selection
    InPatternType = self:AddInput("Pattern Type", "PatternType", {
        LINKID_DataType = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default = 0.0,
        { MBTNC_AddButton = "Radial",  MBTNCD_ButtonWidth = 1 / 4 },
        { MBTNC_AddButton = "Grid",    MBTNCD_ButtonWidth = 1 / 4 },
        { MBTNC_AddButton = "Organic", MBTNCD_ButtonWidth = 1 / 4 },
        { MBTNC_AddButton = "Mixed",   MBTNCD_ButtonWidth = 1 / 4 },
        INP_Integer = true,
    })
    -- Enhanced connection line creation with curved options
    -- Add this as a new input parameter in your Create() function:
    InConnectionStyle = self:AddInput("Connection Style", "ConnectionStyle", {
        LINKID_DataType = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default = 0.0,
        { MBTNC_AddButton = "Manhattan",    MBTNCD_ButtonWidth = 1 / 3 },
        { MBTNC_AddButton = "Curved",       MBTNCD_ButtonWidth = 1 / 3 },
        { MBTNC_AddButton = "Circular Arc", MBTNCD_ButtonWidth = 1 / 3 },
        INP_Integer = true,
    })

    InCurvature = self:AddInput("Curvature", "Curvature", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_MinScale = 0.0,
        INP_MaxScale = 2.0,
        INP_Default = 0.5,
    })

    -- Point Generation Controls
    InPointDensity = self:AddInput("Point Density", "PointDensity", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_MinScale = 0.1,
        INP_MaxScale = 1.0,
        INP_Default = 0.5,
    })
    InPointJitter = self:AddInput("Point Jitter", "PointJitter", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_MinScale = 0.1,
        INP_MaxScale = 1.0,
        INP_Default = 0.0,
    })
    InRandomSeed = self:AddInput("Random Seed", "RandomSeed", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_MinScale = 1,
        INP_MaxScale = 1000,
        INP_Default = 42,
        INP_Integer = true,
    })

    -- Node Shape Controls
    InNodeShape = self:AddInput("Node Shape", "NodeShape", {
        LINKID_DataType = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default = 0.0,
        { MBTNC_AddButton = "Circle",   MBTNCD_ButtonWidth = 1 / 4 },
        { MBTNC_AddButton = "Square",   MBTNCD_ButtonWidth = 1 / 4 },
        { MBTNC_AddButton = "Triangle", MBTNCD_ButtonWidth = 1 / 4 },
        { MBTNC_AddButton = "Mixed",    MBTNCD_ButtonWidth = 1 / 4 },
        INP_Integer = true,
    })

    InNodeSize = self:AddInput("Node Size", "NodeSize", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_MinScale = 0.001,
        INP_MaxScale = 0.1,
        INP_Default = 0.02,
    })

    -- Line Controls
    InLineThickness = self:AddInput("Line Thickness", "LineThickness", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_MinScale = 0.0001,
        INP_MaxScale = 0.02,
        INP_Default = 0.003,
    })

    InGrowthIterations = self:AddInput("Growth Iterations", "GrowthIterations", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_MinScale = 1,
        INP_MaxScale = 10,
        INP_Default = 3,
        INP_Integer = true,
    })

    InTrimFactor = self:AddInput("Trim Factor", "TrimFactor", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_MinScale = 0.0,
        INP_MaxScale = 0.5,
        INP_Default = 0.3,
    })

    -- Color Controls
    InTraceR = self:AddInput("Trace Red", "TraceRed", {
        ICS_Name = "Trace Color",
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 0.2,
        INP_MaxScale = 1.0,
        CLRC_ShowWheel = false,
        IC_ControlGroup = 1,
        IC_ControlID = 0,
    })

    InTraceG = self:AddInput("Trace Green", "TraceGreen", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 0.8,
        IC_ControlGroup = 1,
        IC_ControlID = 1,
    })

    InTraceB = self:AddInput("Trace Blue", "TraceBlue", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 1.0,
        IC_ControlGroup = 1,
        IC_ControlID = 2,
    })

    InNodeR = self:AddInput("Node Red", "NodeRed", {
        ICS_Name = "Node Color",
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 0.1,
        INP_MaxScale = 1.0,
        CLRC_ShowWheel = false,
        IC_ControlGroup = 2,
        IC_ControlID = 0,
    })

    InNodeG = self:AddInput("Node Green", "NodeGreen", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 0.9,
        IC_ControlGroup = 2,
        IC_ControlID = 1,
    })

    InNodeB = self:AddInput("Node Blue", "NodeBlue", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 1.0,
        IC_ControlGroup = 2,
        IC_ControlID = 2,
    })

    InCenter = self:AddInput("Center", "Center", {
        LINKID_DataType      = "Point",
        INPID_InputControl   = "OffsetControl",
        INPID_PreviewControl = "CrosshairControl",
        INP_Disabled         = true,
        IC_Visible           = false,
        PC_Visible           = false
    })
    InCustomScale = self:AddInput("Custom Shape Scale ", "CustomScale", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Default = 1.0,
        INP_MinScale = 0.0,
        INP_MaxScale = 1.0
    })

    -- Input/Output
    InImage = self:AddInput("Input", "Input", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
    })

    OutImage = self:AddOutput("Output", "Output", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
    })
end

-- Utility Functions
function distance(p1, p2)
    return math.sqrt((p1.x - p2.x) ^ 2 + (p1.y - p2.y) ^ 2)
end

function angle(p1, p2)
    return math.atan2(p2.y - p1.y, p2.x - p1.x)
end

function randomPoint(bounds, rng)
    return {
        x = bounds.minX + rng() * (bounds.maxX - bounds.minX),
        y = bounds.minY + rng() * (bounds.maxY - bounds.minY)
    }
end

-- Pattern Generation Functions
function generateRadialPattern(density, bounds, rng, jitter)
    -- Generate points in a radial pattern with jitter
    local points = {}
    local center = { x = 0, y = 0 }
    local numRings = math.floor(density * 8)
    local maxRadius = 0.8

    -- Add center point
    table.insert(points, center)

    for ring = 1, numRings do
        local radius = (ring / numRings) * maxRadius
        local pointsInRing = math.floor(ring * density * 6)

        for i = 1, pointsInRing do
            local angle = (i / pointsInRing) * 2 * math.pi + rng() * 0.5
            local r = radius + (rng() - 0.5) * 0.1
            table.insert(points, {
                x = math.cos(angle) * r,
                y = math.sin(angle) * r
            })
        end
    end

    return points
end

function generateGridPattern(density, bounds, rng, jitter)
    local points = {}
    local gridSize = math.floor(density * 20)
    local jitter = jitter

    for i = -gridSize, gridSize do
        for j = -gridSize, gridSize do
            if math.abs(i) + math.abs(j) < gridSize * 1.5 then
                local x = (i / gridSize) * 0.8 + (rng() - 0.5) * jitter
                local y = (j / gridSize) * 0.8 + (rng() - 0.5) * jitter
                table.insert(points, { x = x, y = y })
            end
        end
    end

    return points
end

function generateOrganicPattern(density, bounds, rng, jitter)
    local points = {}
    local numPoints = math.floor(density * 150)

    -- Generate clustered points
    local numClusters = math.floor(density * 5)

    for cluster = 1, numClusters do
        local centerX = (rng() - 0.5) * 1.2
        local centerY = (rng() - 0.5) * 1.2
        local clusterSize = rng() * 0.3 + 0.1
        local pointsInCluster = math.floor(numPoints / numClusters)

        for i = 1, pointsInCluster do
            local angle = rng() * 2 * math.pi
            local radius = rng() * clusterSize
            local x = centerX + math.cos(angle) * radius
            local y = centerY + math.sin(angle) * radius

            if x >= -0.9 and x <= 0.9 and y >= -0.9 and y <= 0.9 then
                table.insert(points, { x = x, y = y })
            end
        end
    end

    return points
end

function generateMixedPattern(density, bounds, rng, jitter)
    local radialPoints = generateRadialPattern(density * 0.5, bounds, rng, jitter)
    local organicPoints = generateOrganicPattern(density * 0.3, bounds, rng, jitter)
    local gridPoints = generateGridPattern(density * 0.2, bounds, rng, jitter)

    local allPoints = {}
    for _, p in ipairs(radialPoints) do table.insert(allPoints, p) end
    for _, p in ipairs(organicPoints) do table.insert(allPoints, p) end
    for _, p in ipairs(gridPoints) do table.insert(allPoints, p) end

    return allPoints
end

-- Connection Generation
function generateConnections(points, maxConnections, rng)
    local connections = {}

    for i, point in ipairs(points) do
        local distances = {}

        -- Calculate distances to all other points
        for j, otherPoint in ipairs(points) do
            if i ~= j then
                table.insert(distances, {
                    index = j,
                    distance = distance(point, otherPoint)
                })
            end
        end

        -- Sort by distance
        table.sort(distances, function(a, b) return a.distance < b.distance end)

        -- Connect to nearest neighbors
        local connectionsCount = math.min(maxConnections, #distances)
        for k = 1, connectionsCount do
            if distances[k].distance < 0.3 then -- Max connection distance
                table.insert(connections, {
                    start = i,
                    finish = distances[k].index,
                    distance = distances[k].distance
                })
            end
        end
    end

    return connections
end

-- Growth and Trimming
function growConnections(points, connections, iterations, rng)
    local newConnections = {}

    -- Copy existing connections
    for _, conn in ipairs(connections) do
        table.insert(newConnections, conn)
    end

    for iter = 1, iterations do
        local growth = {}

        for _, conn in ipairs(newConnections) do
            if rng() < 0.3 then -- Growth probability
                -- Find points near this connection
                local midX = (points[conn.start].x + points[conn.finish].x) / 2
                local midY = (points[conn.start].y + points[conn.finish].y) / 2

                for i, point in ipairs(points) do
                    local distToMid = distance({ x = midX, y = midY }, point)
                    if distToMid < 0.15 and i ~= conn.start and i ~= conn.finish then
                        table.insert(growth, {
                            start = conn.start,
                            finish = i,
                            distance = distance(points[conn.start], point)
                        })
                    end
                end
            end
        end

        -- Add growth connections
        for _, g in ipairs(growth) do
            table.insert(newConnections, g)
        end
    end

    return newConnections
end

function trimConnections(connections, trimFactor)
    if trimFactor <= 0 then return connections end

    -- Sort by distance (longest first)
    table.sort(connections, function(a, b) return a.distance > b.distance end)

    -- Remove a percentage of longest connections
    local removeCount = math.floor(#connections * trimFactor)
    local trimmed = {}

    for i = removeCount + 1, #connections do
        table.insert(trimmed, connections[i])
    end

    return trimmed
end

-- Shape Creation Functions
function createCircleShape(x, y, radius)
    local shape = Shape()
    local segments = 16

    shape:MoveTo(x + radius, y)
    for i = 1, segments do
        local angle = (i / segments) * 2 * math.pi
        shape:LineTo(x + math.cos(angle) * radius, y + math.sin(angle) * radius)
    end
    shape:Close()

    return shape
end

function createSquareShape(x, y, size)
    local shape = Shape()
    local half = size / 2
    shape:AddRectangle(x - half, x + half, y - half, y + half, 0, 8)
    return shape
end

function createTriangleShape(x, y, size)
    local shape = Shape()
    local height = size * 0.866 -- equilateral triangle height

    shape:MoveTo(x, y + height / 2)
    shape:LineTo(x - size / 2, y - height / 2)
    shape:LineTo(x + size / 2, y - height / 2)
    shape:Close()

    return shape
end

-- Replace your existing createConnectionLine function with this enhanced version:
function createConnectionLine(points, connection, thickness, connectionStyle, curvature)
    local shape = Shape()
    local startPoint = points[connection.start]
    local endPoint = points[connection.finish]

    if connectionStyle == 0 then
        -- Original Manhattan routing
        local midX = (startPoint.x + endPoint.x) / 2
        shape:MoveTo(startPoint.x, startPoint.y)
        shape:LineTo(midX, startPoint.y)
        shape:LineTo(midX, endPoint.y)
        shape:LineTo(endPoint.x, endPoint.y)
    elseif connectionStyle == 1 then
        -- Smooth curved connection
        local dx = endPoint.x - startPoint.x
        local dy = endPoint.y - startPoint.y
        local distance = math.sqrt(dx * dx + dy * dy)

        -- Calculate control points for bezier curve
        local midX = startPoint.x + dx * 0.5
        local midY = startPoint.y + dy * 0.5

        -- Add perpendicular offset for curve
        local perpX = -dy / distance * curvature * 0.2
        local perpY = dx / distance * curvature * 0.2

        local ctrl1X = startPoint.x + dx * 0.25 + perpX
        local ctrl1Y = startPoint.y + dy * 0.25 + perpY
        local ctrl2X = startPoint.x + dx * 0.75 + perpX
        local ctrl2Y = startPoint.y + dy * 0.75 + perpY

        shape:MoveTo(startPoint.x, startPoint.y)
        shape:BezierTo(ctrl1X, ctrl1Y, ctrl2X, ctrl2Y, endPoint.x, endPoint.y)
    elseif connectionStyle == 2 then
        -- Circular arc routing
        local centerX = (startPoint.x + endPoint.x) / 2
        local centerY = (startPoint.y + endPoint.y) / 2
        local dx = endPoint.x - startPoint.x
        local dy = endPoint.y - startPoint.y
        local distance = math.sqrt(dx * dx + dy * dy)

        -- Calculate radius based on distance and curvature
        local radius = distance * (0.5 + curvature * 0.5)

        -- Find circle center offset
        local perpX = -dy / distance
        local perpY = dx / distance

        local arcCenterX = centerX + perpX * radius * curvature
        local arcCenterY = centerY + perpY * radius * curvature

        -- Calculate start and end angles
        local startAngle = math.atan2(startPoint.y - arcCenterY, startPoint.x - arcCenterX)
        local endAngle = math.atan2(endPoint.y - arcCenterY, endPoint.x - arcCenterX)

        -- Ensure we take the shorter arc
        local angleDiff = endAngle - startAngle
        if angleDiff > math.pi then
            endAngle = endAngle - 2 * math.pi
        elseif angleDiff < -math.pi then
            endAngle = endAngle + 2 * math.pi
        end

        -- Create arc with multiple segments for smoothness
        local segments = 16
        shape:MoveTo(startPoint.x, startPoint.y)

        for i = 1, segments do
            local t = i / segments
            local currentAngle = startAngle + (endAngle - startAngle) * t
            local x = arcCenterX + math.cos(currentAngle) * radius
            local y = arcCenterY + math.sin(currentAngle) * radius
            shape:LineTo(x, y)
        end
    end

    -- Convert to outline for thickness
    return shape:OutlineOfShape(thickness, "OLT_Solid", "OJT_Round", 8, "SWM_Normal", 8)
end

-- Alternative: Concentric circle-based connections for radial patterns
function createConcentricConnectionLine(points, connection, thickness, centerPoint)
    local shape = Shape()
    local startPoint = points[connection.start]
    local endPoint = points[connection.finish]

    -- Calculate distances from center
    local startDist = distance(startPoint, centerPoint or { x = 0, y = 0 })
    local endDist = distance(endPoint, centerPoint or { x = 0, y = 0 })

    -- Use the average distance as the radius for the connecting arc
    local arcRadius = (startDist + endDist) / 2

    -- Calculate angles
    local startAngle = math.atan2(startPoint.y, startPoint.x)
    local endAngle = math.atan2(endPoint.y, endPoint.x)

    -- Ensure we take the shorter arc
    local angleDiff = endAngle - startAngle
    if angleDiff > math.pi then
        endAngle = endAngle - 2 * math.pi
    elseif angleDiff < -math.pi then
        endAngle = endAngle + 2 * math.pi
    end

    -- Create the arc
    local segments = math.max(8, math.floor(math.abs(angleDiff) * 16))
    shape:MoveTo(startPoint.x, startPoint.y)

    -- First, connect to the arc radius
    local startArcX = math.cos(startAngle) * arcRadius
    local startArcY = math.sin(startAngle) * arcRadius
    shape:LineTo(startArcX, startArcY)

    -- Then follow the arc
    for i = 1, segments do
        local t = i / segments
        local currentAngle = startAngle + (endAngle - startAngle) * t
        local x = math.cos(currentAngle) * arcRadius
        local y = math.sin(currentAngle) * arcRadius
        shape:LineTo(x, y)
    end

    -- Finally connect to the end point
    shape:LineTo(endPoint.x, endPoint.y)

    return shape:OutlineOfShape(thickness, "OLT_Solid", "OJT_Round", 8, "SWM_Normal", 8)
end

function convertY(y, ref_img)
    return y * (ref_img.Height * ref_img.YScale) / (ref_img.Width * ref_img.XScale)
end

function Process(req)
    local img              = InImage:GetValue(req)
    local out              = img:CopyOf()

    -- Get parameter values
    local patternType      = InPatternType:GetValue(req).Value
    local pointDensity     = InPointDensity:GetValue(req).Value
    local randomSeed       = InRandomSeed:GetValue(req).Value
    local nodeShape        = InNodeShape:GetValue(req).Value
    local nodeSize         = InNodeSize:GetValue(req).Value
    local lineThickness    = InLineThickness:GetValue(req).Value
    local growthIterations = InGrowthIterations:GetValue(req).Value
    local trimFactor       = InTrimFactor:GetValue(req).Value
    local pointJitter      = InPointJitter:GetValue(req).Value

    local traceR           = InTraceR:GetValue(req).Value
    local traceG           = InTraceG:GetValue(req).Value
    local traceB           = InTraceB:GetValue(req).Value
    local nodeR            = InNodeR:GetValue(req).Value
    local nodeG            = InNodeG:GetValue(req).Value
    local nodeB            = InNodeB:GetValue(req).Value
    local position         = InCenter:GetValue(req)
    local cx               = position.X
    local cy               = convertY(position.Y, img)
    local shpaeScale       = InCustomScale:GetValue(req).Value

    local connectionStyle  = InConnectionStyle:GetValue(req).Value
    local curvature        = InCurvature:GetValue(req).Value

    -- Initialize random number generator
    math.randomseed(randomSeed)
    local rng = math.random

    -- Set up rendering objects
    local ic = ImageChannel(out, 8)
    local fs = FillStyle()
    local cs = ChannelStyle()
    local mat = Matrix4()

    local bounds = { minX = -0.9, maxX = 0.9, minY = -0.9, maxY = 0.9 }

    local LineHolder = Shape()
    local NodeHolder = Shape()

    -- Generate points based on pattern type
    local points
    if patternType == 0 then
        points = generateRadialPattern(pointDensity, bounds, rng, pointJitter)
    elseif patternType == 1 then
        points = generateGridPattern(pointDensity, bounds, rng, pointJitter)
    elseif patternType == 2 then
        points = generateOrganicPattern(pointDensity, bounds, rng, pointJitter)
    else
        points = generateMixedPattern(pointDensity, bounds, rng, pointJitter)
    end

    -- Generate connections
    local connections = generateConnections(points, 4, rng)

    -- Grow connections
    connections = growConnections(points, connections, growthIterations, rng)

    -- Trim connections
    connections = trimConnections(connections, trimFactor)

    -- Render connections (traces)
    cs.Color = Pixel { R = traceR, G = traceG, B = traceB, A = 1 }

    for _, connection in ipairs(connections) do
        local lineShape = createConnectionLine(points, connection, lineThickness, connectionStyle, curvature)
        LineHolder:AddShape(lineShape)
    end

    mat:Identity()
    mat:Scale(shpaeScale, shpaeScale, 1.0)
    --mat:RotZ(rotation)
    mat:Move(cx, cy, 0)
    ic:SetStyleFill(fs)
    ic:ShapeFill(LineHolder:TransformOfShape(mat))
    ic:PutToImage("CM_Merge", cs)



    -- Render nodes
    cs.Color = Pixel { R = nodeR, G = nodeG, B = nodeB, A = 1 }

    for i, point in ipairs(points) do
        local nodeShapeObj
        local shapeType = nodeShape

        -- Mixed mode: random shape selection
        if nodeShape == 3 then
            shapeType = math.floor(rng() * 3)
        end

        if shapeType == 0 then
            nodeShapeObj = createCircleShape(point.x, point.y, nodeSize)
        elseif shapeType == 1 then
            nodeShapeObj = createSquareShape(point.x, point.y, nodeSize * 2)
        else
            nodeShapeObj = createTriangleShape(point.x, point.y, nodeSize * 2)
        end
        NodeHolder:AddShape(nodeShapeObj)
    end
    mat:Identity()
    mat:Scale(shpaeScale, shpaeScale, 1.0)
    --mat:RotZ(rotation)
    mat:Move(cx, cy, 0)
    ic:SetStyleFill(fs)
    ic:ShapeFill(NodeHolder:TransformOfShape(mat))
    ic:PutToImage("CM_Merge", cs)


    OutImage:Set(req, out)
end
