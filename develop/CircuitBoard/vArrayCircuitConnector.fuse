-- ============================================================================
-- modules
-- ============================================================================
local jsonutils = self and require("vjsonutils") or nil
local arrayutils = self and require("varrayutils") or nil
-- ============================================================================
-- constants
-- ============================================================================
FUSE_NAME = "vArrayCircuitConnector"
DATATYPE = "Text"
MAX_INPUTS = 24
-- ============================================================================
-- fuse
-- ============================================================================
FuRegisterClass(FUSE_NAME, CT_Tool, {
    REGID_DataType      = DATATYPE,
    REGID_InputDataType = DATATYPE,
    REG_NoCommonCtrls   = true,
    REGS_Category       = "Kartaverse\\Vonk Ultra\\Mograph\\__dev",
    REGS_Name           = FUSE_NAME,
    REGS_OpDescription  = "Generates abstract circuit board lines and components",
    REGS_OpIconString   = FUSE_NAME,
    REGS_IconID         = "Icons.Tools.Icons.TextPlus",
    REG_TimeVariant     = true,
    REGB_Temporal       = true,
})


function Create()
    -- Enhanced connection line creation with curved options
    -- Add this as a new input parameter in your Create() function:
    InConnectionStyle = self:AddInput("Connection Style", "ConnectionStyle", {
        LINKID_DataType = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default = 0.0,
        { MBTNC_AddButton = "Manhattan",         MBTNCD_ButtonWidth = 1 / 8 },
        { MBTNC_AddButton = "Curved",            MBTNCD_ButtonWidth = 1 / 8 },
        { MBTNC_AddButton = "Circular Arc",      MBTNCD_ButtonWidth = 1 / 8 },
        { MBTNC_AddButton = "Slanted Manhattan", MBTNCD_ButtonWidth = 1 / 8 },
        { MBTNC_AddButton = "Spiral",            MBTNCD_ButtonWidth = 1 / 8 },
        { MBTNC_AddButton = "Wavy",              MBTNCD_ButtonWidth = 1 / 8 },
        { MBTNC_AddButton = "Diagonal",          MBTNCD_ButtonWidth = 1 / 8 }, -- NEW
        { MBTNC_AddButton = "Rounded Manhattan", MBTNCD_ButtonWidth = 1 / 8 }, -- NEW
        { MBTNC_AddButton = "Smooth Curved",     MBTNCD_ButtonWidth = 1 / 8 }, -- NEW
        INP_Integer = true,
    })
    InNoDuplicateConnections = self:AddInput("No Duplicate Connections", "NoDuplicateConnections", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 1.0, -- Checked by default
    })

    InCurvature = self:AddInput("Curvature", "Curvature", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_MinScale = 0.0,
        INP_MaxScale = 2.0,
        INP_Default = 0.0,
    })

    InReachDistance = self:AddInput("Reach distance", "Reachdistance", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_MinScale = 0.0,
        INP_MaxScale = 2.0,
        INP_Default = 0.3,
    })


    -- Point Generation Controls
    InMaxConnections = self:AddInput("Max Connections", "MaxConnections", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ScrewControl",
        INP_MinScale       = 1,
        INP_MaxScale       = 10,
        INP_Default        = 4,
        INP_Integer        = true,
        IC_Visible         = false,
        PC_Visible         = false
    })

    InCenter = self:AddInput("Center", "Center", {
        LINKID_DataType      = "Point",
        INPID_InputControl   = "OffsetControl",
        INPID_PreviewControl = "CrosshairControl",
        INP_Disabled         = true,
        IC_Visible           = false,
        PC_Visible           = false
    })


    InGlobal = self:AddInput("Global Scale ", "GlobalScale", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Default = 0.5,
        INP_MinScale = 0.0,
        INP_MaxScale = 1.0
    })
    self:BeginControlNest("Line Settings", "linesettings", false, {})

    -- Line Controls
    InLineThickness = self:AddInput("Line Thickness", "LineThickness", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_MinScale = 0.0001,
        INP_MaxScale = 0.02,
        INP_Default = 0.003,
    })

    InTrimFactor = self:AddInput("Trim Factor", "TrimFactor", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_MinScale = 0.0,
        INP_MaxScale = 0.5,
        INP_Default = 0.3,
    })

    -- Color Controls
    InTraceR = self:AddInput("Trace Red", "TraceRed", {
        ICS_Name = "Line Color",
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 0.2,
        INP_MaxScale = 1.0,
        CLRC_ShowWheel = false,
        IC_ControlGroup = 1,
        IC_ControlID = 0,
    })

    InTraceG = self:AddInput("Trace Green", "TraceGreen", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 0.8,
        IC_ControlGroup = 1,
        IC_ControlID = 1,
    })

    InTraceB = self:AddInput("Trace Blue", "TraceBlue", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 1.0,
        IC_ControlGroup = 1,
        IC_ControlID = 2,
    })


    self:EndControlNest()
    self:BeginControlNest("Node Settings", "nodesettings", false, {})
    InShowNodes = self:AddInput("Show Nodes", "showNodes", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default        = 0,
    })
    -- Node Shape Controls
    InNodeShape = self:AddInput("Node Shape", "NodeShape", {
        LINKID_DataType = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default = 0.0,
        { MBTNC_AddButton = "Circle",   MBTNCD_ButtonWidth = 1 / 5 },
        { MBTNC_AddButton = "Square",   MBTNCD_ButtonWidth = 1 / 5 },
        { MBTNC_AddButton = "Triangle", MBTNCD_ButtonWidth = 1 / 5 },
        --  { MBTNC_AddButton = "Mixed",    MBTNCD_ButtonWidth = 1 / 5 },
        { MBTNC_AddButton = "Custom",   MBTNCD_ButtonWidth = 1 / 5 },
        INP_Integer = true,
    })

    InNodeSize = self:AddInput("Node Size", "NodeSize", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_MinScale = 0.001,
        INP_MaxScale = 0.1,
        INP_Default = 0.02,
    })
    InNodeR = self:AddInput("Node Red", "NodeRed", {
        ICS_Name = "Node Color",
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 0.1,
        INP_MaxScale = 1.0,
        CLRC_ShowWheel = false,
        IC_ControlGroup = 2,
        IC_ControlID = 0,
    })

    InNodeG = self:AddInput("Node Green", "NodeGreen", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 0.9,
        IC_ControlGroup = 2,
        IC_ControlID = 1,
    })

    InNodeB = self:AddInput("Node Blue", "NodeBlue", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 1.0,
        IC_ControlGroup = 2,
        IC_ControlID = 2,
    })



    self:EndControlNest()
    self:BeginControlNest("Style Settings", "stylesettings", false, {})
    InFilter = self:AddInput("Filter", "Filter", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 3.0,
        {
            MBTNC_AddButton    = "Box",
            MBTNCD_ButtonWidth = 0.25,
        },
        {
            MBTNC_AddButton    = "Bartlett",
            MBTNCD_ButtonWidth = 0.25,
        },
        {
            MBTNC_AddButton    = "Multi-box",
            MBTNCD_ButtonWidth = 0.25,
        },
        {
            MBTNC_AddButton    = "Gaussian",
            MBTNCD_ButtonWidth = 0.25,
        },
        IC_Visible = false,
        PC_Visible = false
    })
    InSoftEdge = self:AddInput("Soft Edge", "SoftEdge", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinAllowed     = 0,
        INP_MaxScale       = 50,
        INP_Default        = 0,
        IC_Visible         = false,
        PC_Visible         = false
    })
    InLineType = self:AddInput("Line Type", "LineType", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 0.0,
        MBTNC_ShowName     = false,
        {
            MBTNC_AddButton    = "Solid",
            MBTNCD_ButtonWidth = 0.33,
        },
        {
            MBTNC_AddButton    = "Dash",
            MBTNCD_ButtonWidth = 0.34,
        },
        {
            MBTNC_AddButton    = "Dot",
            MBTNCD_ButtonWidth = 0.33,
        },
        {
            MBTNC_AddButton    = "Dash Dot",
            MBTNCD_ButtonWidth = 0.5,
        },
        {
            MBTNC_AddButton    = "Dash Dot Dot",
            MBTNCD_ButtonWidth = 0.5,
        },
    })
    InJoinType = self:AddInput("Join Type", "JoinType", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 2.0,
        MBTNC_ShowName     = false,
        {
            MBTNC_AddButton    = "Bevel",
            MBTNCD_ButtonWidth = 0.3333,
        },
        {
            MBTNC_AddButton    = "Round",
            MBTNCD_ButtonWidth = 0.3333,
        },
    })

    self:EndControlNest()
    -- Input/Output
    InImage = self:AddInput("Input", "Input", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
    })

    InShape = self:AddInput("JSON Custom Shape", "JSONCustomShape", {
        LINKID_DataType = "ScriptVal",
        INPID_InputControl = "ImageControl",
        LINK_Main = 3,
    })

    InArray = self:AddInput("Array A", "ArrayA", {
        INPID_InputControl = "ImageControl",
        LINKID_DataType = DATATYPE,
        INP_Required = false,
        LINK_Main = 2,
    })

    OutImage = self:AddOutput("Output", "Output", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
    })
end

-- Utility Functions
function distance(p1, p2)
    return math.sqrt((p1.x - p2.x) ^ 2 + (p1.y - p2.y) ^ 2)
end

function angle(p1, p2)
    return math.atan2(p2.y - p1.y, p2.x - p1.x)
end

function randomPoint(bounds, rng)
    return {
        x = bounds.minX + rng() * (bounds.maxX - bounds.minX),
        y = bounds.minY + rng() * (bounds.maxY - bounds.minY)
    }
end

-- Connection Generation
function generateConnections_Dupes(points, maxConnections, rng, reachDistance)
    local connections = {}

    for i, point in ipairs(points) do
        local distances = {}

        -- Calculate distances to all other points
        for j, otherPoint in ipairs(points) do
            if i ~= j then
                table.insert(distances, {
                    index = j,
                    distance = distance(point, otherPoint)
                })
            end
        end

        -- Sort by distance
        table.sort(distances, function(a, b) return a.distance < b.distance end)

        -- Connect to nearest neighbors
        local connectionsCount = math.min(maxConnections, #distances)
        for k = 1, connectionsCount do
            if distances[k].distance < reachDistance then -- Max connection distance
                table.insert(connections, {
                    start = i,
                    finish = distances[k].index,
                    distance = distances[k].distance
                })
            end
        end
    end

    return connections
end

function generateConnections_noDupes(points, maxConnections, rng, reachDistance)
    local noDupes = true

    local connections = {}
    -- Get the checkbox value (default to true if not present)


    for i, point in ipairs(points) do
        local distances = {}

        -- Calculate distances to all other points
        for j, otherPoint in ipairs(points) do
            if i ~= j then
                table.insert(distances, {
                    index = j,
                    distance = distance(point, otherPoint)
                })
            end
        end

        -- Sort by distance
        table.sort(distances, function(a, b) return a.distance < b.distance end)

        -- Connect to nearest neighbors
        local connectionsCount = math.min(maxConnections, #distances)
        for k = 1, connectionsCount do
            local j = distances[k].index
            if distances[k].distance < reachDistance then -- Max connection distance
                if not noDupes or i < j then
                    table.insert(connections, {
                        start = i,
                        finish = j,
                        distance = distances[k].distance
                    })
                end
            end
        end
    end

    return connections
end

-- Growth and Trimming
function growConnections(points, connections, iterations, rng)
    local newConnections = {}

    -- Copy existing connections
    for _, conn in ipairs(connections) do
        table.insert(newConnections, conn)
    end

    for iter = 1, iterations do
        local growth = {}

        for _, conn in ipairs(newConnections) do
            if rng() < 0.3 then -- Growth probability
                -- Find points near this connection
                local midX = (points[conn.start].x + points[conn.finish].x) / 2
                local midY = (points[conn.start].y + points[conn.finish].y) / 2

                for i, point in ipairs(points) do
                    local distToMid = distance({ x = midX, y = midY }, point)
                    if distToMid < 0.15 and i ~= conn.start and i ~= conn.finish then
                        table.insert(growth, {
                            start = conn.start,
                            finish = i,
                            distance = distance(points[conn.start], point)
                        })
                    end
                end
            end
        end

        -- Add growth connections
        for _, g in ipairs(growth) do
            table.insert(newConnections, g)
        end
    end

    return newConnections
end

function trimConnections(connections, trimFactor)
    if trimFactor <= 0 then return connections end

    -- Sort by distance (longest first)
    table.sort(connections, function(a, b) return a.distance > b.distance end)

    -- Remove a percentage of longest connections
    local removeCount = math.floor(#connections * trimFactor)
    local trimmed = {}

    for i = removeCount + 1, #connections do
        table.insert(trimmed, connections[i])
    end

    return trimmed
end

-- Shape Creation Functions
function createCircleShape(x, y, radius)
    local shape = Shape()
    local segments = 16

    shape:MoveTo(x + radius, y)
    for i = 1, segments do
        local angle = (i / segments) * 2 * math.pi
        shape:LineTo(x + math.cos(angle) * radius, y + math.sin(angle) * radius)
    end
    shape:Close()

    return shape
end

function createSquareShape(x, y, size)
    local shape = Shape()
    local half = size / 2
    shape:AddRectangle(x - half, x + half, y - half, y + half, 0, 8)
    return shape
end

function createTriangleShape(x, y, size)
    local shape = Shape()
    local height = size * 0.866 -- equilateral triangle height

    shape:MoveTo(x, y + height / 2)
    shape:LineTo(x - size / 2, y - height / 2)
    shape:LineTo(x + size / 2, y - height / 2)
    shape:Close()

    return shape
end

-- Replace your existing createConnectionLine function with this enhanced version:
function createConnectionLine(points, connection, thickness, connectionStyle, curvature, outline_line_type,
                              outline_join_type)
    local shape = Shape()
    local startPoint = points[connection.start]
    local endPoint = points[connection.finish]

    if connectionStyle == 0 then
        -- Original Manhattan routing
        local midX = (startPoint.x + endPoint.x) / 2
        shape:MoveTo(startPoint.x, startPoint.y)
        shape:LineTo(midX, startPoint.y)
        shape:LineTo(midX, endPoint.y)
        shape:LineTo(endPoint.x, endPoint.y)
    elseif connectionStyle == 1 then
        -- Smooth curved connection (Bezier)
        local dx = endPoint.x - startPoint.x
        local dy = endPoint.y - startPoint.y
        local distance = math.sqrt(dx * dx + dy * dy)
        local perpX = -dy / distance * curvature * 0.2
        local perpY = dx / distance * curvature * 0.2
        local ctrl1X = startPoint.x + dx * 0.25 + perpX
        local ctrl1Y = startPoint.y + dy * 0.25 + perpY
        local ctrl2X = startPoint.x + dx * 0.75 + perpX
        local ctrl2Y = startPoint.y + dy * 0.75 + perpY
        shape:MoveTo(startPoint.x, startPoint.y)
        shape:BezierTo(ctrl1X, ctrl1Y, ctrl2X, ctrl2Y, endPoint.x, endPoint.y)
    elseif connectionStyle == 2 then
        -- Circular arc routing
        local centerX = (startPoint.x + endPoint.x) / 2
        local centerY = (startPoint.y + endPoint.y) / 2
        local dx = endPoint.x - startPoint.x
        local dy = endPoint.y - startPoint.y
        local distance = math.sqrt(dx * dx + dy * dy)

        -- Calculate radius based on distance and curvature
        local radius = distance * (0.5 + curvature * 0.5)

        -- Find circle center offset
        local perpX = -dy / distance
        local perpY = dx / distance

        local arcCenterX = centerX + perpX * radius * curvature
        local arcCenterY = centerY + perpY * radius * curvature

        -- Calculate start and end angles
        local startAngle = math.atan2(startPoint.y - arcCenterY, startPoint.x - arcCenterX)
        local endAngle = math.atan2(endPoint.y - arcCenterY, endPoint.x - arcCenterX)

        -- Ensure we take the shorter arc
        local angleDiff = endAngle - startAngle
        if angleDiff > math.pi then
            endAngle = endAngle - 2 * math.pi
        elseif angleDiff < -math.pi then
            endAngle = endAngle + 2 * math.pi
        end

        -- Create arc with multiple segments for smoothness
        local segments = 16
        shape:MoveTo(startPoint.x, startPoint.y)

        for i = 1, segments do
            local t = i / segments
            local currentAngle = startAngle + (endAngle - startAngle) * t
            local x = arcCenterX + math.cos(currentAngle) * radius
            local y = arcCenterY + math.sin(currentAngle) * radius
            shape:LineTo(x, y)
        end
    elseif connectionStyle == 3 then
        -- Slanted Manhattan (45-degree)
        local dx = endPoint.x - startPoint.x
        local dy = endPoint.y - startPoint.y
        local step = math.min(math.abs(dx), math.abs(dy))
        local signX = dx >= 0 and 1 or -1
        local signY = dy >= 0 and 1 or -1
        local midX = startPoint.x + step * signX
        local midY = startPoint.y + step * signY
        shape:MoveTo(startPoint.x, startPoint.y)
        shape:LineTo(midX, midY)
        shape:LineTo(endPoint.x, endPoint.y)
    elseif connectionStyle == 4 then
        -- Spiral routing
        local cx = (startPoint.x + endPoint.x) / 2
        local cy = (startPoint.y + endPoint.y) / 2
        local startRadius = math.sqrt((startPoint.x - cx) ^ 2 + (startPoint.y - cy) ^ 2)
        local endRadius = math.sqrt((endPoint.x - cx) ^ 2 + (endPoint.y - cy) ^ 2)
        local startAngle = math.atan2(startPoint.y - cy, startPoint.x - cx)
        local endAngle = math.atan2(endPoint.y - cy, endPoint.x - cx)
        -- Ensure spiral goes the short way
        if endAngle < startAngle then endAngle = endAngle + 2 * math.pi end
        local spiralTurns = 1 + math.abs(endAngle - startAngle) / (2 * math.pi)
        local segments = 32
        shape:MoveTo(startPoint.x, startPoint.y)
        for i = 1, segments do
            local t = i / segments
            local angle = startAngle + (endAngle - startAngle) * t + spiralTurns * 2 * math.pi * t * curvature
            local radius = startRadius + (endRadius - startRadius) * t
            local x = cx + math.cos(angle) * radius
            local y = cy + math.sin(angle) * radius
            shape:LineTo(x, y)
        end
        shape:LineTo(endPoint.x, endPoint.y)
    elseif connectionStyle == 5 then
        -- Wavy/Sine routing
        local segments = 32
        local amplitude = 0.05 + curvature * 0.1
        shape:MoveTo(startPoint.x, startPoint.y)
        for i = 1, segments do
            local t = i / segments
            local x = startPoint.x + (endPoint.x - startPoint.x) * t
            local y = startPoint.y + (endPoint.y - startPoint.y) * t
            -- Perpendicular vector
            local dx = endPoint.x - startPoint.x
            local dy = endPoint.y - startPoint.y
            local len = math.sqrt(dx * dx + dy * dy)
            local nx = -dy / len
            local ny = dx / len
            local wave = math.sin(t * math.pi * 4) * amplitude
            x = x + nx * wave
            y = y + ny * wave
            shape:LineTo(x, y)
        end



        shape:LineTo(endPoint.x, endPoint.y)
    elseif connectionStyle == 6 then
        -- Diagonal routing
        local midX = (startPoint.x + endPoint.x) / 2
        local midY = (startPoint.y + endPoint.y) / 2

        shape:MoveTo(startPoint.x, startPoint.y)
        shape:LineTo(midX, midY)
        shape:LineTo(endPoint.x, endPoint.y)
    elseif connectionStyle == 7 then
        -- Orthogonal with Rounded Corners (Rounded Manhattan)
        local midX = (startPoint.x + endPoint.x) / 2
        local cornerRadius = math.min(math.abs(endPoint.x - startPoint.x), math.abs(endPoint.y - startPoint.y)) *
            (0.2 + curvature * 0.3)

        -- Determine directions
        local xDir = (endPoint.x > startPoint.x) and 1 or -1
        local yDir = (endPoint.y > startPoint.y) and 1 or -1

        -- Start the path
        shape:MoveTo(startPoint.x, startPoint.y)

        if math.abs(endPoint.x - startPoint.x) > 2 * cornerRadius and math.abs(endPoint.y - startPoint.y) > 2 * cornerRadius then
            -- First horizontal segment (to corner start)
            local corner1StartX = midX - cornerRadius * xDir
            shape:LineTo(corner1StartX, startPoint.y)

            -- First rounded corner (horizontal to vertical turn)
            local corner1EndY = startPoint.y + cornerRadius * yDir
            local cx1 = corner1StartX + cornerRadius * xDir -- Control point 1
            local cy1 = startPoint.y
            local cx2 = midX                                -- Control point 2
            local cy2 = startPoint.y + cornerRadius * yDir
            shape:BezierTo(cx1, cy1, cx2, cy2, midX, corner1EndY)

            -- Vertical segment (between corners)
            local corner2StartY = endPoint.y - cornerRadius * yDir
            shape:LineTo(midX, corner2StartY)

            -- Second rounded corner (vertical to horizontal turn)
            local corner2EndX = midX + cornerRadius * xDir
            local cx3 = midX        -- Control point 1
            local cy3 = corner2StartY + cornerRadius * yDir
            local cx4 = corner2EndX -- Control point 2
            local cy4 = endPoint.y
            shape:BezierTo(cx3, cy3, cx4, cy4, corner2EndX, endPoint.y)

            -- Final horizontal segment (to end point)
            shape:LineTo(endPoint.x, endPoint.y)
        else
            -- Fallback to Manhattan if not enough space for rounding
            shape:LineTo(midX, startPoint.y)
            shape:LineTo(midX, endPoint.y)
            shape:LineTo(endPoint.x, endPoint.y)
        end
    elseif connectionStyle == 8 then
        -- Smooth curved connection (Bezier)
        local dx = endPoint.x - startPoint.x
        local dy = endPoint.y - startPoint.y
        local distance = math.sqrt(dx * dx + dy * dy)
        local perpX = -dy / distance * curvature * 0.2
        local perpY = dx / distance * curvature * 0.2
        local ctrl1X = startPoint.x + dx * 0.25 + perpX
        local ctrl1Y = startPoint.y + dy * 0.25 + perpY
        local ctrl2X = startPoint.x + dx * 0.75 + perpX
        local ctrl2Y = startPoint.y + dy * 0.75 + perpY
        shape:MoveTo(startPoint.x, startPoint.y)
        shape:BezierTo(ctrl1X, ctrl1Y, ctrl2X, ctrl2Y, endPoint.x, endPoint.y)
    end

    -- Convert to outline for thickness


    -- return shape
    return shape:OutlineOfShape(thickness, outline_line_type, outline_join_type, 8, "SWM_Normal", 8)
end

function convertY(y, ref_img)
    return y * (ref_img.Height * ref_img.YScale) / (ref_img.Width * ref_img.XScale)
end

function Process(req)
    local img = InImage:GetValue(req)
    local out = img:CopyOf()


    local array_str_shape = InShape:GetValue(req):GetValue() or {}
    local arrayA = jsonutils.decode(InArray:GetValue(req).Value).array or {}


    local tbl_Shape = {}
    if array_str_shape and array_str_shape ~= "" then
        local inp_shape_tbl = array_str_shape
        if inp_shape_tbl ~= nil and type(inp_shape_tbl) == "table" then
            tbl_Shape = inp_shape_tbl
        end
    end

    -- Get parameter values
    local randomSeed       = 100
    local nodeShape        = InNodeShape:GetValue(req).Value
    local nodeSize         = InNodeSize:GetValue(req).Value
    local lineThickness    = InLineThickness:GetValue(req).Value
    local growthIterations = 0
    local trimFactor       = InTrimFactor:GetValue(req).Value
    local noDupes          = InNoDuplicateConnections:GetValue(req).Value
    local maxConnections   = InMaxConnections:GetValue(req).Value
    local reachDistance    = InReachDistance:GetValue(req).Value

    local traceR           = InTraceR:GetValue(req).Value
    local traceG           = InTraceG:GetValue(req).Value
    local traceB           = InTraceB:GetValue(req).Value
    local nodeR            = InNodeR:GetValue(req).Value
    local nodeG            = InNodeG:GetValue(req).Value
    local nodeB            = InNodeB:GetValue(req).Value
    local position         = InCenter:GetValue(req)
    local cx               = position.X
    local cy               = convertY(position.Y, img)
    local shpaeScale       = InGlobal:GetValue(req).Value

    local connectionStyle  = InConnectionStyle:GetValue(req).Value
    local curvature        = InCurvature:GetValue(req).Value

    local linetype         = math.floor(InLineType:GetValue(req).Value + 0.5) + 1
    local jointype         = math.floor(InJoinType:GetValue(req).Value + 0.5) + 1


    local outline_line_type = {
        "OLT_Solid",
        "OLT_Dash",
        "OLT_Dot",
        "OLT_DashDot",
        "OLT_DashDotDot",
    }
    local blurfilters       = {
        "BT_Box",
        "BT_Bartless",
        "BT_MultiBox",
        "BT_Gaussian",
    }
    local outline_join_type = {
        "OJT_Bevel",
        "OJT_Round",
    }
    local outline_cap_type  = {
        "OCT_Butt",
        "OCT_Square",
        "OCT_Round",
    }

    -- Initialize random number generator
    math.randomseed(randomSeed)
    local rng = math.random

    -- Set up rendering objects
    local ic = ImageChannel(out, 8)
    local fs = FillStyle()
    local cs = ChannelStyle()
    local mat = Matrix4()

    local bounds = { minX = -0.9, maxX = 0.9, minY = -0.9, maxY = 0.9 }

    local LineHolder = Shape()
    local NodeHolder = Shape()

    -- Generate points based on pattern type
    local points = {}
    for i, point in ipairs(arrayA) do
        points[i] = { x = point[1], y = point[2] }
    end


    -- Generate connections
    local connections
    if noDupes == 0 then
        connections = generateConnections_Dupes(points, maxConnections, rng, reachDistance)
    else
        connections = generateConnections_noDupes(points, maxConnections, rng, reachDistance)
    end



    -- Grow connections
    connections = growConnections(points, connections, growthIterations, rng)

    -- Trim connections
    connections = trimConnections(connections, trimFactor)

    -- Render connections (traces)
    cs.Color = Pixel { R = traceR, G = traceG, B = traceB, A = 1 }

    for _, connection in ipairs(connections) do
        local lineShape = createConnectionLine(points, connection, lineThickness, connectionStyle, curvature,
            outline_line_type[linetype], outline_join_type[jointype])
        LineHolder:AddShape(lineShape)
    end


    mat:Identity()
    mat:Scale(shpaeScale, shpaeScale, 1.0)
    --mat:RotZ(rotation)
    mat:Move(cx, cy, 0)
    ic:SetStyleFill(fs)
    ic:ShapeFill(LineHolder:TransformOfShape(mat))
    ic:PutToImage("CM_Merge", cs)



    -- Render nodes

    if InShowNodes:GetValue(req).Value > 0 then
        cs.Color = Pixel { R = nodeR, G = nodeG, B = nodeB, A = 1 }

        for i, point in ipairs(points) do
            local nodeShapeObj = Shape()
            local shapeType = nodeShape

            -- Mixed mode: random shape selection

            if shapeType == 0 then
                nodeShapeObj = createCircleShape(point.x, point.y, nodeSize)
            elseif shapeType == 1 then
                nodeShapeObj = createSquareShape(point.x, point.y, nodeSize * 2)
            elseif shapeType == 3 then
                local cus_mat = Matrix4()
                cus_mat:Identity()
                cus_mat:Move(point.x, point.y, 0)
                nodeShapeObj:AddShape(tbl_Shape[2])
                nodeShapeObj = nodeShapeObj:TransformOfShape(cus_mat)
            else
                nodeShapeObj = createTriangleShape(point.x, point.y, nodeSize * 2)
            end
            NodeHolder:AddShape(nodeShapeObj)
        end
        mat:Identity()
        mat:Scale(shpaeScale, shpaeScale, 1.0)
        --mat:RotZ(rotation)
        mat:Move(cx, cy, 0)
        ic:SetStyleFill(fs)
        ic:ShapeFill(NodeHolder:TransformOfShape(mat))
        ic:PutToImage("CM_Merge", cs)
    end

    OutImage:Set(req, out)
end
