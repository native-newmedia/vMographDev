-- ============================================================================
-- modules
-- ============================================================================

-- ============================================================================
-- constants
-- ============================================================================
FUSE_NAME = "Stagger"
DATATYPE = "ScriptVal"
-- ============================================================================
-- fuse
-- ============================================================================
FuRegisterClass(FUSE_NAME, CT_Tool, {
    REGID_DataType      = DATATYPE,
    REGID_InputDataType = DATATYPE,
    REGS_Category       = "Kartaverse\\Vonk Ultra\\Mograph\\__dev",
    REGS_Name           = FUSE_NAME,
    REGS_OpDescription  = "Apply staggered timing to animations",
    REGS_IconID         = "Icons.Tools.Icons.sRender",
    REG_Version         = 100,
    REG_TimeVariant     = true, -- required to disable caching of the current time parameter
    REGB_Temporal       = true, -- ensures reliability in Resolve 15
    REG_Unpredictable   = true,

})

function Create()
    -- Input controls
    InNumberValue = self:AddInput("Number Input", "NumberInput", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.0,
    })

    InPointValue = self:AddInput("Point Input", "PointInput", {
        LINKID_DataType = "Point",
        INPID_InputControl = "OffsetControl",
        -- INP_DefaultX = 0.0,
        -- INP_DefaultY = 0.0,
        LINK_Main = 2,
    })

    InInputType = self:AddInput("Input Type", "InputType", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ComboControl",
        INP_Default = 0.0, -- Default to Array mode
        INP_Integer = true,
        { CCS_AddString = "Number", },
        { CCS_AddString = "Point (X,Y)", },
        { CCS_AddString = "3D Point (X,Y,Z)", },
        { CCS_AddString = "Array", },
        CC_LabelPosition = "Horizontal",
    })

    InIndex = self:AddInput("Index", "Index", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.0,
        INP_Integer = true,
        INP_MinAllowed = 0,
        INP_MaxAllowed = 100,
    })

    InStaggerX = self:AddInput("Stagger X", "StaggerX", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 1.0,
        --IC_Visible = false,
    })

    InStaggerY = self:AddInput("Stagger Y", "StaggerY", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 1.0,
        --IC_Visible = false,
    })

    InStaggerZ = self:AddInput("Stagger Z", "StaggerZ", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 1.0,
        --IC_Visible = false,
    })

    InAxisOffset = self:AddInput("Axis Offset", "AxisOffset", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.1,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        --IC_Visible = false,
    })

    InAmount = self:AddInput("Stagger Amount", "StaggerAmount", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 1.0,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 2.0,
    })

    InDelay = self:AddInput("Stagger Delay", "StaggerDelay", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 1.0,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 2.0,
    })

    InMode = self:AddInput("Mode", "Mode", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ComboControl",
        INP_Default = 0.0,
        INP_Integer = true,
        { CCS_AddString = "Linear Delay", },
        { CCS_AddString = "Wave", },
        { CCS_AddString = "Exponential", },
        CC_LabelPosition = "Horizontal",
    })

    InWaveFreq = self:AddInput("Wave Frequency", "WaveFreq", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 1.0,
        INP_MinAllowed = 0.1,
        INP_MaxAllowed = 10.0,
        -- IC_Visible = false,
    })
    InScriptVal = self:AddInput("ScriptValArray", "ScriptValArray", {
        LINKID_DataType = "ScriptVal",
        INPID_InputControl = "ImageControl",
        LINK_Main = 1,
    })
    -- Output
    OutNumberValue = self:AddOutput("Number Output", "NumberOutput", {
        LINKID_DataType = "Number",
        LINK_Main = 1,
    })

    OutPointValue = self:AddOutput("Point Output", "PointOutput", {
        LINKID_DataType = "Point",
        LINK_Main = 2,
    })
    OutScriptVal = self:AddOutput("OutputData", "OutputData", {
        LINKID_DataType = DATATYPE,
        LINK_Main = 3
    })
end

function Process(req)
    -- local input_type = InInputType:GetValue(req).Value or 0
    -- local index = InIndex:GetValue(req).Value or 0
    -- local delay = InDelay:GetValue(req).Value or 0.2
    -- local amount = InAmount:GetValue(req).Value or 1.0
    -- local mode = InMode:GetValue(req).Value or 0
    -- local wave_freq = InWaveFreq:GetValue(req).Value or 1.0
    -- -- local time = req.Time
    -- local stagger_x = InStaggerX:GetValue(req).Value > 0.5
    -- local stagger_y = InStaggerY:GetValue(req).Value > 0.5
    -- local stagger_z = InStaggerZ:GetValue(req).Value > 0.5
    -- local axis_offset = InAxisOffset:GetValue(req).Value or 0.1

    local InputArray = InScriptVal:GetValue(req):GetValue() or {}



    -- Array processing
    local output_array = {}
    --[[
    for i, element in ipairs(InputArray) do
        local element_output = {}
        local element_index = i - 1 -- Convert to 0-based index for stagger calculation

        if type(element) == "table" then
            -- Process each component of the element
            for j, value in ipairs(element) do
                local component_delay = delay

                -- Apply axis offset for Y and Z components
                if j == 2 and stagger_y then
                    component_delay = delay + axis_offset
                elseif j == 3 and stagger_z then
                    component_delay = delay + (axis_offset * 2)
                end

                -- Only apply stagger if the corresponding axis is enabled
                local should_stagger = true
                if j == 1 then
                    should_stagger = stagger_x
                elseif j == 2 then
                    should_stagger = stagger_y
                elseif j == 3 then
                    should_stagger = stagger_z
                end

                if should_stagger then
                    element_output[j] = processStagger(value, element_index, component_delay, amount, mode, wave_freq,
                        time)
                else
                    element_output[j] = value
                end
            end
        else
            -- Process single value
            element_output = processStagger(element, element_index, delay, amount, mode, wave_freq, time)
        end

        output_array[i] = element_output
    end

    -- ]]

    OutScriptVal:Set(req, ScriptValParam(InputArray))
end

--[[
function processStagger(input_value, index, delay, amount, mode, wave_freq, time)
    local output_value = input_value

    if mode == 0 then
        -- Linear delay mode
        local staggered_time = math.max(0, time - (index * delay))
        local time_factor = time > 0 and (staggered_time / time) or 0
        output_value = input_value * time_factor * amount
    elseif mode == 1 then
        -- Wave mode
        local wave_offset = math.sin((time * wave_freq) + (index * delay))
        output_value = input_value + (wave_offset * amount)
    elseif mode == 2 then
        -- Exponential mode
        local exp_delay = math.pow(index * delay, 1.5)
        local staggered_time = math.max(0, time - exp_delay)
        local time_factor = time > 0 and (staggered_time / time) or 0
        output_value = input_value * time_factor * amount
    end

    return output_value
end ]]

--[[
function Process(req)
    local input_type = InInputType:GetValue(req).Value or 0
    local index = InIndex:GetValue(req).Value or 0
    local delay = InDelay:GetValue(req).Value or 0.2
    local amount = InAmount:GetValue(req).Value or 1.0
    local mode = InMode:GetValue(req).Value or 0
    local wave_freq = InWaveFreq:GetValue(req).Value or 1.0
    local time = req.Time
    local stagger_x = InStaggerX:GetValue(req).Value > 0.5
    local stagger_y = InStaggerY:GetValue(req).Value > 0.5
    local stagger_z = InStaggerZ:GetValue(req).Value > 0.5
    local axis_offset = InAxisOffset:GetValue(req).Value or 0.1

    --local InputArray = InScriptVal:GetValue(req):GetValue() or {}


    local InputArray = {}
    local scriptVal = InScriptVal:GetValue(req)
    if scriptVal and scriptVal.IsValid then
        InputArray = scriptVal:Get() or {}
    end


    if input_type == 0 then
        -- Number processing
        local input_value = InNumberValue:GetValue(req).Value or 0
        local output_value = processStagger(input_value, index, delay, amount, mode, wave_freq, time)
        OutNumberValue:Set(req, Number(output_value))
    elseif input_type == 1 or input_type == 2 then
        -- Point processing
        local input_point = InPointValue:GetValue(req)

        local output_x = input_point.X
        local output_y = input_point.Y
        local output_z = (input_type == 2) and (input_point.Z or 0) or 0

        if stagger_x then
            output_x = processStagger(input_point.X, index, delay, amount, mode, wave_freq, time)
        end

        if stagger_y then
            local y_delay = delay + axis_offset
            output_y = processStagger(input_point.Y, index, y_delay, amount, mode, wave_freq, time)
        end

        if stagger_z and input_type == 2 then
            local z_delay = delay + (axis_offset * 2)
            output_z = processStagger(output_z, index, z_delay, amount, mode, wave_freq, time)
        end

        if input_type == 2 then
            OutPointValue:Set(req, Point3D(output_x, output_y, output_z))
        else
            OutPointValue:Set(req, Point(output_x, output_y))
        end
    elseif input_type == 3 then
        -- Array processing
        local output_array = {}

        for i, element in ipairs(InputArray) do
            local element_output = {}
            local element_index = i - 1 -- Convert to 0-based index for stagger calculation

            if type(element) == "table" then
                -- Process each component of the element
                for j, value in ipairs(element) do
                    local component_delay = delay

                    -- Apply axis offset for Y and Z components
                    if j == 2 and stagger_y then
                        component_delay = delay + axis_offset
                    elseif j == 3 and stagger_z then
                        component_delay = delay + (axis_offset * 2)
                    end

                    -- Only apply stagger if the corresponding axis is enabled
                    local should_stagger = true
                    if j == 1 then
                        should_stagger = stagger_x
                    elseif j == 2 then
                        should_stagger = stagger_y
                    elseif j == 3 then
                        should_stagger = stagger_z
                    end

                    if should_stagger then
                        element_output[j] = processStagger(value, element_index, component_delay, amount, mode, wave_freq,
                            time)
                    else
                        element_output[j] = value
                    end
                end
            else
                -- Process single value
                element_output = processStagger(element, element_index, delay, amount, mode, wave_freq, time)
            end

            output_array[i] = element_output
        end

        OutScriptVal:Set(req, ScriptValParam(output_array))
    end


    -- OutScriptVal:Set(req, ScriptValParam({ output_x, output_y, output_z }))
end ]]
