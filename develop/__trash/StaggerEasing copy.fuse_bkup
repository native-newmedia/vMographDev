-- MaterialEasing.fuse
-- Blackmagic Fusion Fuse Plugin implementing Material Design 3 easing curves
-- with UI preview spline, remapping duration, and forward/reverse outputs

FUSE_NAME = "StaggerEasing"

FuRegisterClass(FUSE_NAME, CT_Tool, {
  REGS_Name          = FUSE_NAME,
  REGS_OpIconString  = FUSE_NAME,
  REGS_OpDescription = "Material Design 3 Easing Curve Tool",
  REGS_Category      = "Kartaverse\\Vonk Ultra\\Mograph\\__dev",
  REG_Version        = 1,
  REG_TimeVariant    = true, -- required to disable caching of the current time parameter
  REGB_Temporal      = true, -- ensures reliability in Resolve 15
  REG_Unpredictable  = true,
})





-- Define easing curves using cubic bezier format: {x1, y1, x2, y2}
local easing_curves = {
  { 0.3,  0,    0.8,  0.15 }, -- Emphasized Accelerate
  { 0.05, 0.7,  0.1,  1.0 },  -- Emphasized Decelerate
  { 0.2,  0,    0,    1.0 },
  { 0.3,  0,    1,    1 },
  { 0,    0,    0,    1 },
  { 0.4,  0,    0.2,  1 },
  { 0.4,  0,    1,    1 },
  { 0,    0,    0.2,  1 },
  { 0.42, 1.67, 0.21, 0.9 },
  { 0.38, 1.21, 0.22, 1.0 },
  { 0.39, 1.29, 0.35, 0.98 },
  { 0.31, 0.94, 0.34, 1.0 },
  { 0.34, 0.8,  0.34, 1.0 },
  { 0.34, 0.88, 0.34, 1.0 },
  { 0.27, 1.06, 0.18, 1.0 },
  { 0.27, 1.06, 0.18, 1.0 },
  { 0.27, 1.06, 0.18, 1.0 },
  { 0.31, 0.94, 0.34, 1.0 },
  { 0.34, 0.8,  0.34, 1.0 },
  { 0.34, 0.88, 0.34, 1.0 },
}



local ConnectionLabel = [[
<table align="center" cellspacing="8">
  <tr>
    <td style="text-align: center;"></td>
    <td style="text-align: center; background-color: #051626; color: white; padding: 5px; font-weight: bold;">[ ]] ..
    FUSE_NAME .. [[ ]</td>
    <td style="text-align: center;">  →  [ vJSONShapeRender Custom Shape ]</td>
  </tr>
</table>
]]
function Create()
  -- [[ Creates the user interface. ]]
  InLabelConnect = self:AddInput(ConnectionLabel, 'LabelConnect', {
    LINKID_DataType = 'Text',
    INPID_InputControl = 'LabelControl',
    LBLC_MultiLine = true,
    INP_External = false,
    INP_Passive = true,
    IC_ControlPage = -1,
    IC_NoLabel = true,
    IC_NoReset = true,
  })
  self:BeginControlNest("Material Easing", "MaterialEasing", true)

  InTime = self:AddInput("Time", "Time", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_MinScale = 0.0,
    INP_MaxScale = 1.0,
    INP_Default = 0.0,
    --LINK_Main = 1,
  })

  InOffset = self:AddInput("Start Offset", "StartOffset", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 0.0,
    INP_MinScale = 0.0,
    INP_MaxScale = 10.0
  })

  InDuration = self:AddInput("Duration", "Duration", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 1.0,
    INP_MinScale = 0.01,
    INP_MaxScale = 10.0
  })

  InStartValue = self:AddInput("Start Value", "StartValue", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 0.0,
    INP_MinScale = -10000,
    INP_MaxScale = 10000,
    --LINK_Main = 2,
  })

  InEndValue = self:AddInput("End Value", "EndValue", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 1.0,
    INP_MinScale = -10000,
    INP_MaxScale = 10000,
    --LINK_Main = 3,
  })

  InEaseType = self:AddInput("Easing Type", "EaseType", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
    INP_Integer = true,
    INP_Default = 0,
    { CCS_AddString = "Emphasized Accelerate" },
    { CCS_AddString = "Emphasized Decelerate" },
    { CCS_AddString = "Standard" },
    { CCS_AddString = "Standard Accelerate" },
    { CCS_AddString = "Standard Decelerate" },
    { CCS_AddString = "Legacy" },
    { CCS_AddString = "Legacy Accelerate" },
    { CCS_AddString = "Legacy Decelerate" },
    { CCS_AddString = "Expressive Fast Spatial" },
    { CCS_AddString = "Expressive Default Spatial" },
    { CCS_AddString = "Expressive Slow Spatial" },
    { CCS_AddString = "Expressive Fast Effects" },
    { CCS_AddString = "Expressive Default Effects" },
    { CCS_AddString = "Expressive Slow Effects" },
    { CCS_AddString = "Standard Fast Spatial" },
    { CCS_AddString = "Standard Default Spatial" },
    { CCS_AddString = "Standard Slow Spatial" },
    { CCS_AddString = "Standard Fast Effects" },
    { CCS_AddString = "Standard Default Effects" },
    { CCS_AddString = "Standard Slow Effects" },
    INP_DoNotifyChanged = true,
  })

  InPreviewSpline = self:AddInput("Preview Curve", "TimeSpline", {
    LINKID_DataType = "LookUpTable",
    INPID_InputControl = "SplineControl",
    INPID_AddModifier = "LUTBezier",
    ICS_Name = "",
    SPC_SplineColor = MakeRGBA(0.8, 1, 0.6, 0.4),
    SPC_Show = true,
    SPC_HorizontalGridLines = 5,
    SPC_VerticalGridLines = 3,
    SPC_BarSize = 1,
    SPC_Margin = 5,
    SPCD_Height = 1,
    SPC_ShowInOut = true,
    IC_Visible = false,
  })

  InLabel = self:AddInput("", "Labeltbl", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    LBLC_MultiLine = true,
    LBLC_Wrap = true,
    LBLC_WordWrap = true,
    INP_External = false,
    INP_Passive = true,
    IC_NoLabel = true,
    IC_NoReset = true,
    INP_DoNotifyChanged = true,
  })

  self:EndControlNest()


  self:BeginControlNest("Stagger Easing", "StaggerEasing", true)
  -- Input controls
  InNumberValue = self:AddInput("Number Input", "NumberInput", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0.0,
  })

  InPointValue = self:AddInput("Point Input", "PointInput", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    -- INP_DefaultX = 0.0,
    -- INP_DefaultY = 0.0,
    LINK_Main = 2,
  })

  InInputType = self:AddInput("Input Type", "InputType", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
    INP_Default = 0.0, -- Default to Array mode
    INP_Integer = true,
    { CCS_AddString = "Number", },
    { CCS_AddString = "Point (X,Y)", },
    { CCS_AddString = "3D Point (X,Y,Z)", },
    { CCS_AddString = "Array", },
    CC_LabelPosition = "Horizontal",
  })
  InMode = self:AddInput("Mode", "Mode", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ComboControl",
    INP_Default = 0.0,
    INP_Integer = true,
    { CCS_AddString = "Linear", },
    { CCS_AddString = "Wave", },
    { CCS_AddString = "Exponential", },
    { CCS_AddString = "Pulse Wave", },
    { CCS_AddString = "Triangle Wave", },
    { CCS_AddString = "Sawtooth Wave", },

    CC_LabelPosition = "Horizontal",
    INP_DoNotifyChanged = true,
  })

  InIndex = self:AddInput("Index", "Index", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0.0,
    INP_Integer = true,
    INP_MinAllowed = 0,
    -- INP_MaxAllowed = 100,
  })

  InStaggerX = self:AddInput("Stagger X", "StaggerX", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_Default = 1.0,
  })

  InStaggerY = self:AddInput("Stagger Y", "StaggerY", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_Default = 1.0,
  })

  InStaggerZ = self:AddInput("Stagger Z", "StaggerZ", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_Default = 1.0,
  })

  InAxisOffset = self:AddInput("Axis Offset", "AxisOffset", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0.1,
  })

  InAmount = self:AddInput("Stagger Amount", "StaggerAmount", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 1.0,
    INP_MinAllowed = 0.0,
  })

  InDelay = self:AddInput("Stagger Delay", "StaggerDelay", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0.0,
    INP_MinAllowed = 0.0,
  })



  InWaveFreq = self:AddInput("Wave Frequency", "WaveFreq", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0.01,
    INP_MinAllowed = 0.0,
    IC_Visible = false,
  })

  -- Custom parameter controls for processStagger
  InClampOutput = self:AddInput("Clamp Output", "ClampOutput", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_Default = 0.0,
    IC_Visible = false,
  })

  InMinValue = self:AddInput("Min Value", "MinValue", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0,
    IC_Visible = false,
  })

  InMaxValue = self:AddInput("Max Value", "MaxValue", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 1,
    IC_Visible = false,
  })

  InReverse = self:AddInput("Reverse Index", "ReverseIndex", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_Default = 1.0,
    IC_Visible = false,
  })

  InYoyo = self:AddInput("Yoyo", "Yoyo", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
    INP_Default = 1.0,
    IC_Visible = false,
  })

  InSteps = self:AddInput("Steps (for Step/Staircase)", "Steps", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 5,
    INP_MinAllowed = 1,
    INP_MaxAllowed = 100,
    IC_Visible = false,
  })

  InPulseWidth = self:AddInput("Pulse Width (for Pulse Wave)", "PulseWidth", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INP_Default = 0.5,
    INP_MinAllowed = 0.01,
    INP_MaxAllowed = 1.0,
    IC_Visible = false,
  })

  -- ...existing controls...
  self:EndControlNest()


  InScriptVal = self:AddInput("ScriptValArray", "ScriptValArray", {
    LINKID_DataType = "ScriptVal",
    INPID_InputControl = "ImageControl",
    LINK_Main = 1,
  })
  OutScriptVal = self:AddOutput("OutputData", "OutputData", {
    LINKID_DataType = "ScriptVal",
    LINK_Main = 3
  })



  OutForward = self:AddOutput("Forward Value", "ForwardValue", {
    LINKID_DataType = "Number",
    --LINK_Main = 1,
  })

  OutReverse = self:AddOutput("Reverse Value", "ReverseValue", {
    LINKID_DataType = "Number",
    --LINK_Main = 2,
  })
end

function math.clamp(val, lower, upper)
  assert(val and lower and upper, "not very useful error message here")
  if lower > upper then lower, upper = upper, lower end -- swap if boundaries supplied the wrong way
  return math.max(lower, math.min(upper, val))
end

-- Cubic Bézier interpolation function
local function cubicBezier(t, p0, p1, p2, p3)
  local u = 1 - t
  return u ^ 3 * p0 + 3 * u ^ 2 * t * p1 + 3 * u * t ^ 2 * p2 + t ^ 3 * p3
end

-- Binary subdivision solve for Bezier x = t
local function solveBezierX(t, x1, x2)
  local t0, t1 = 0, 1
  for i = 1, 10 do
    local tm = (t0 + t1) * 0.5
    local x = cubicBezier(tm, 0, x1, x2, 1)
    if math.abs(x - t) < 1e-4 then return tm end
    if x > t then t1 = tm else t0 = tm end
  end
  return (t0 + t1) * 0.5
end

local function getEasedValue(t, curve)
  local x1, y1, x2, y2 = table.unpack(curve)
  local bezT = solveBezierX(t, x1, x2)
  return cubicBezier(bezT, 0, y1, y2, 1)
end

function MakeRGBA(r, g, b, a)
  return ((((a or 1) * 255) * 256 + r * 255) * 256 + g * 255) * 256 + b * 255
end

function NotifyChanged(inp, param, time)
  if inp == InMode then
    -- Hide all mode-specific controls first
    InWaveFreq:SetAttrs({ IC_Visible = false })
    InSteps:SetAttrs({ IC_Visible = false })
    InPulseWidth:SetAttrs({ IC_Visible = false })
    InYoyo:SetAttrs({ IC_Visible = false })
    InClampOutput:SetAttrs({ IC_Visible = false })
    InMinValue:SetAttrs({ IC_Visible = false })
    InMaxValue:SetAttrs({ IC_Visible = false })

    -- Show controls relevant to the selected mode


    if param.Value == 0 then     -- Linear

    elseif param.Value == 1 then -- Wave
      InWaveFreq:SetAttrs({ IC_Visible = true })
    elseif param.Value == 2 then -- Exponential


    elseif param.Value == 3 then -- Pulse Wave
      InPulseWidth:SetAttrs({ IC_Visible = true })
      InWaveFreq:SetAttrs({ IC_Visible = true })
    elseif param.Value == 4 or param.Value == 5 then -- Triangle/Sawtooth Wave
      InWaveFreq:SetAttrs({ IC_Visible = true })
    end
  end





  if inp == InEaseType then
    local idx = param.Value + 1
    local c = easing_curves[idx] or { 0, 0, 1, 1 }
    local spline = {}
    local resolution = 0.01
    for i = 0, 1, resolution do
      local eased = getEasedValue(i, c)
      table.insert(spline, { i, eased })

      --local y = math.floor((1 - eased) * 200 + 0.5)
      --local px = math.floor(i * 100 + 0.5)
      --local py = math.floor((1 - eased) * 100 + 0.5)
    end


    local tileSize = 1

    -- HTML Header
    local html_str = ""
    html_str = html_str .. [[
<table style="width:200; border: 1px solid black; background-color: black;">
<tr style="height:]] .. tostring(200) .. [[px;">]]

    -- Process each cell
    local t = {}
    for i, v in ipairs(spline) do
      t[#t + 1] = string.format("(%.2f, %.2f)", v[1], v[2])

      -- HTML Color
      local r = math.clamp(math.ceil(tonumber(string.format("%.2f", v[2])) * 255), 0, 255)
      local g = 0.0
      local b = 0.0
      local rgb_str = string.format("#%02X%02X%02X", r, g, b)
      html_str = html_str .. [[
<td style="background-color:]] ..
          rgb_str ..
          [[;"><img width="]] ..
          tostring(tileSize) ..
          [[" height="]] ..
          tostring((v[2]) * 50) ..
          [[" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAABlBMVEUAAAAmRcn2EULJAAAAAnRSTlP/AOW3MEoAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAOSURBVAiZY/j/n4EUBAD9Th/hNOA7twAAAABJRU5ErkJggg=='/><div style='margin:0 0;'>x</div></td>
]]
    end

    -- HTML Footer
    html_str = html_str .. "</tr>\n</table>"

    InLabel:SetSource(Text(html_str), 0)
  end
end

function Process(req)
  local time = req.Time --InTime:GetValue(req).Value
  local offset = InOffset:GetValue(req).Value
  local duration = InDuration:GetValue(req).Value
  local startVal = InStartValue:GetValue(req).Value
  local endVal = InEndValue:GetValue(req).Value



  -- Check duration in milliseconds

  local normTime = math.min(math.max((time - offset) / duration, 0), 1)
  local idx = InEaseType:GetValue(req).Value + 1
  local curve = easing_curves[idx] or { 0, 0, 1, 1 }

  local eased = getEasedValue(normTime, curve)


  local interp = startVal + (endVal - startVal) * eased
  local interpRev = endVal - (endVal - startVal) * eased

  OutForward:Set(req, interp)
  OutReverse:Set(req, interpRev)

  -- Process Stagger Easing

  local input_type = InInputType:GetValue(req).Value or 0
  local index = InIndex:GetValue(req).Value or 0
  local delay = InDelay:GetValue(req).Value or 0.2
  local amount = InAmount:GetValue(req).Value or 1.0
  local mode = InMode:GetValue(req).Value or 0
  local wave_freq = InWaveFreq:GetValue(req).Value or 1.0
  --local time = req.Time
  local stagger_x = InStaggerX:GetValue(req).Value > 0.5
  local stagger_y = InStaggerY:GetValue(req).Value > 0.5
  local stagger_z = InStaggerZ:GetValue(req).Value > 0.5
  local axis_offset = InAxisOffset:GetValue(req).Value or 0.1


  local InputArray = InScriptVal:GetValue(req):GetValue() or {}
  local output_array = {}





  for i, element in ipairs(InputArray) do
    local element_output = {}
    local element_index = i - 1 -- Convert to 0-based index for stagger calculation

    if type(element) == "table" then
      -- Process each component of the element
      for j, value in ipairs(element) do
        local component_delay = delay

        --Apply axis offset for Y and Z components
        if j == 2 and stagger_y then
          component_delay = delay + axis_offset
        elseif j == 3 and stagger_z then
          component_delay = delay + (axis_offset * 2)
        end

        -- Only apply stagger if the corresponding axis is enabled
        local should_stagger = true
        if j == 1 then
          should_stagger = stagger_x
        elseif j == 2 then
          should_stagger = stagger_y
        elseif j == 3 then
          should_stagger = stagger_z
        end

        if should_stagger then
          element_output[j] = processStagger(value, element_index, component_delay, amount, mode, wave_freq, time)
        else
          element_output[j] = value
        end
      end
    else
      -- Process single value
      element_output = processStagger(element, element_index, delay, amount, mode, wave_freq, time)
    end

    output_array[i] = element_output
  end







  OutScriptVal:Set(req, ScriptValParam(output_array))
end

function processStagger(input_value, index, delay, amount, mode, wave_freq, time, custom_params)
  local output_value = input_value

  -- Common parameters
  custom_params = custom_params or {}
  local min_value = custom_params.min_value or -math.huge
  local max_value = custom_params.max_value or math.huge
  local clamp_output = custom_params.clamp_output or false
  local reverse = custom_params.reverse or true
  local yoyo = custom_params.yoyo or true


  -- Reverse index if needed
  local effective_index = reverse and (1 - index) or index
  local output_value = input_value

  -- Yoyo modifier (applies to oscillating modes)
  local yoyo_time = yoyo and (time % (2 / wave_freq)) or time
  local yoyo_dir = yoyo and (math.floor(time * wave_freq) % 2 == 0 and 1 or -1) or 1

  if mode == 0 then
    -- Linear delay mode (original)
    local staggered_time = math.max(0, time - (index * delay))
    local time_factor = time > 0 and (staggered_time / time) or 0
    output_value = input_value * time_factor * amount
  elseif mode == 1 then
    -- Wave mode (original)
    local wave_offset = math.sin((time * wave_freq) + (index * delay))
    output_value = input_value + (wave_offset * amount)
  elseif mode == 2 then
    -- Exponential mode (original)
    local exp_delay = math.pow(index * delay, 1.5)
    local staggered_time = math.max(0, time - exp_delay)
    local time_factor = time > 0 and (staggered_time / time) or 0
    output_value = input_value * time_factor * amount
  elseif mode == 3 then
    -- Pulse wave mode
    local pulse_width = custom_params.pulse_width or 0.5
    local phase = (time * wave_freq + index * delay) % 1
    local pulse = (phase < pulse_width) and 1 or 0
    output_value = input_value * pulse * amount
  elseif mode == 4 then
    -- Triangle wave: ramps up then down (0 to 1 to 0)
    local phase = (time * wave_freq + index * delay) % 1
    local triangle = 2 * math.abs(2 * phase - 1) - 1
    output_value = input_value * ((triangle + 1) / 2) * amount
  elseif mode == 5 then
    -- Sawtooth wave: ramps up then resets (0 to 1)
    local phase = (time * wave_freq + index * delay) % 1
    output_value = input_value * phase * amount
  end

  -- Optional clamping
  if clamp_output then
    output_value = math.min(math.max(output_value, min_value), max_value)
  end

  return output_value
end
