-- ============================================================================
-- modules
-- ============================================================================
local jsonutils = self and require("vjsonutils") or nil
local arrayutils = self and require("varrayutils") or nil

-- ============================================================================
-- constants
-- ============================================================================
FUSE_NAME = "vArrayCameraProjection_BBox"
DATATYPE = "Text"

-- ============================================================================
-- fuse
-- ============================================================================
FuRegisterClass(FUSE_NAME, CT_Tool, {
    REGID_DataType = DATATYPE,
    REGID_InputDataType = DATATYPE,
    REG_NoCommonCtrls = true,
    REGS_Category = "Kartaverse\\Vonk Ultra\\Mograph\\Array\\Modify",
    REGS_Name = FUSE_NAME,
    REGS_OpDescription = "Transforms Array using a perspective projection matrix.",
    REGS_OpIconString = FUSE_NAME,
    REGS_IconID = "Icons.Tools.Icons.Camera3D",
})



function Create()
    -- [[ Creates the user interface. ]]

    local ConnectionLabel = [[
<table align="center" cellspacing="8">
  <tr>
  <td style="text-align: center; padding: 5px;">[vArray] →</td>
    <td style="text-align: center; background-color: #051626; color: white; padding: 5px; font-weight: bold;">[]] ..
        FUSE_NAME .. [[]</td>
    <td style="text-align: center; padding: 5px;">→ [vArrayShapeRender]</td>
  </tr>
</table>
]]

    InConnectionLabel = self:AddInput(ConnectionLabel, "ConnectionLabel", {
        LINKID_DataType = "Text",
        INPID_InputControl = "LabelControl",
        LBLC_MultiLine = true,
        INP_External = false,
        INP_Passive = true,
        IC_ControlPage = -1,
        IC_NoLabel = true,
        IC_NoReset = true,
    })

    self:BeginControlNest("Translation", "Translation", true, { LBLC_PickButton = false })

    TranslateX = self:AddInput("X Offset", "Translate.X", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_MinScale = -100.0,
        INP_MaxScale = 100.0,
    })

    TranslateY = self:AddInput("Y Offset", "Translate.Y", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_MinScale = -100.0,
        INP_MaxScale = 100.0,
    })

    TranslateZ = self:AddInput("Z Offset", "Translate.Z", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 1.0,
        INP_MinScale = -100.0,
        INP_MaxScale = 100.0,
    })
    self:EndControlNest()

    self:BeginControlNest("Rotation", "Rotation", true, { LBLC_PickButton = false })
    InRotOrder = self:AddInput("Rotation Order", "RotOrder", {
        LINKID_DataType = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default = 0,
        { MBTNC_AddButton = " XYZ ", },
        { MBTNC_AddButton = " XZY ", },
        { MBTNC_AddButton = " YXZ ", },
        { MBTNC_AddButton = " YZX ", },
        { MBTNC_AddButton = " ZXY ", },
        { MBTNC_AddButton = " ZYX ", },
        IC_Visible = false,
        PC_Visible = false
    })

    RotateX = self:AddInput("X Rotation", "Rotate.X", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_MaxScale = 360.0,
        IC_Steps = 1,
    })

    RotateY = self:AddInput("Y Rotation", "Rotate.Y", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_MaxScale = 360.0,
        IC_Steps = 1,
    })

    RotateZ = self:AddInput("Z Rotation", "Rotate.Z", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_MaxScale = 360.0,
    })

    self:EndControlNest()
    self:BeginControlNest("Scale", "Scale", true, { LBLC_PickButton = false })
    InLockScale = self:AddInput("Lock X/Y", "LockXY", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 1,
        INP_DoNotifyChanged = true,
    })

    ScaleX = self:AddInput("X Scale", "Scale.X", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 1.0,
    })

    ScaleY = self:AddInput("Y Scale", "Scale.Y", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 1.0,
        IC_Visible = false,
        PC_Visible = false
    })
    self:EndControlNest()

    self:BeginControlNest("perspective projection", "perspective_projection", true, {
        LBLC_PickButton = false,
    })
    InFov = self:AddInput("Field of view", "fov", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Integer = false,
        INP_Default = 90.0,
    })
    InAspect_ratio = self:AddInput("Screen aspect ratio", "aspect_ratio", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 16 / 9,
        IC_Visible = false,
        PC_Visible = false
    })

    InNear = self:AddInput("Near clipping plane", "near", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 0.1,
        IC_Visible = false,
        PC_Visible = false
    })
    InFar = self:AddInput("Far clipping plane", "for", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 1000,
        IC_Visible = false,
        PC_Visible = false
    })

    -- Add fit to view controls
    InFitToView = self:AddInput("Fit to View", "FitToView", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 1,
        INP_DoNotifyChanged = true,
    })

    InViewPadding = self:AddInput("View Padding", "ViewPadding", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Integer = false,
        INP_Default = 0.1,
        INP_MinScale = 0.0,
        INP_MaxScale = 0.5,
    })

    -- Add coordinate system option
    InCoordSystem = self:AddInput("Coordinate System", "CoordSystem", {
        LINKID_DataType = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default = 0,
        { MBTNC_AddButton = "Standard", },
        { MBTNC_AddButton = "Centered", },
        INP_DoNotifyChanged = true,
    })

    self:EndControlNest()

    self:BeginControlNest("Shear", "Shear", true, {
        LBLC_PickButton = false,
        IC_Visible = false,
        PC_Visible = false
    })
    ShearX = self:AddInput("X Shear", "Shear.X", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 0.0,
        IC_Visible = false,
        PC_Visible = false
    })

    ShearY = self:AddInput("Y Shear", "Shear.Y", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 0.0,
        IC_Visible = false,
        PC_Visible = false

    })
    self:EndControlNest()

    InShowInput = self:AddInput("Show Input", "ShowInput", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 1.0,
        INP_External = false,
        INP_DoNotifyChanged = true
    })
    InArray = self:AddInput("Array A", "ArrayA", {
        INPID_InputControl = "ImageControl",
        LINKID_DataType = DATATYPE,
        LINK_Main = 1,
    })

    OutData = self:AddOutput("Output", "Output", {
        LINKID_DataType = "Text",
        LINK_Main = 1,
    })
end

function NotifyChanged(inp, param, time)
    if inp == InLockScale then
        if param.Value > 0.5 then
            ScaleX:SetAttrs({ LINKS_Name = "Scale" })
            ScaleY:SetAttrs({ IC_Visible = false, PC_Visible = false })
        else
            ScaleX:SetAttrs({ LINKS_Name = "X Scale" })
            ScaleY:SetAttrs({ IC_Visible = true, PC_Visible = true })
        end
    end
end

function convertY(y, ref_img)
    return y * (ref_img.Height * ref_img.YScale) / (ref_img.Width * ref_img.XScale)
end

-- Helper function to calculate bounding box of 3D points
function calculate_bounding_box(array)
    if #array == 0 then
        return {min_x = 0, max_x = 0, min_y = 0, max_y = 0, min_z = 0, max_z = 0}
    end
    
    local min_x, max_x = array[1][1], array[1][1]
    local min_y, max_y = array[1][2], array[1][2]
    local min_z, max_z = array[1][3], array[1][3]
    
    for i = 1, #array do
        local x, y, z = array[i][1], array[i][2], array[i][3]
        min_x = math.min(min_x, x)
        max_x = math.max(max_x, x)
        min_y = math.min(min_y, y)
        max_y = math.max(max_y, y)
        min_z = math.min(min_z, z)
        max_z = math.max(max_z, z)
    end
    
    return {
        min_x = min_x, max_x = max_x,
        min_y = min_y, max_y = max_y,
        min_z = min_z, max_z = max_z,
        width = max_x - min_x,
        height = max_y - min_y,
        depth = max_z - min_z,
        center_x = (min_x + max_x) / 2,
        center_y = (min_y + max_y) / 2,
        center_z = (min_z + max_z) / 2
    }
end

function Process(req)
    -- [[ Creates the output. ]]
    local arrayA = jsonutils.decode(InArray:GetValue(req).Value).array or {}

    local _translateX = TranslateX:GetValue(req).Value
    local _translateY = TranslateY:GetValue(req).Value
    local _translateZ = TranslateZ:GetValue(req).Value

    local _rotationZ = RotateZ:GetValue(req).Value
    local _rotationX = RotateX:GetValue(req).Value
    local _rotationY = RotateY:GetValue(req).Value

    local _scaleX = ScaleX:GetValue(req).Value
    local _scaleY = _scaleX

    local _shearX = ShearX:GetValue(req).Value
    local _shearY = ShearY:GetValue(req).Value

    if InLockScale:GetValue(req).Value < 0.5 then
        _scaleX = ScaleX:GetValue(req).Value
        _scaleY = ScaleY:GetValue(req).Value
    end

    local fov = InFov:GetValue(req).Value
    local aspect_ratio = InAspect_ratio:GetValue(req).Value
    local near = InNear:GetValue(req).Value
    local far = InFar:GetValue(req).Value
    local fit_to_view = InFitToView:GetValue(req).Value > 0.5
    local view_padding = InViewPadding:GetValue(req).Value
    local coord_system = InCoordSystem:GetValue(req).Value

    -- Define functions to create transformation matrices
    function translation_matrix(tx, ty, tz)
        return {
            { 1, 0, 0, tx },
            { 0, 1, 0, ty },
            { 0, 0, 1, tz },
            { 0, 0, 0, 1 }
        }
    end

    function scale_matrix(sx, sy, sz)
        return {
            { sx, 0,  0,  0 },
            { 0,  sy, 0,  0 },
            { 0,  0,  sz, 0 },
            { 0,  0,  0,  1 }
        }
    end

    -- Rotation matrix function
    function rotation_matrix_XYZ(angles)
        local cos_x, sin_x = math.cos(angles[1]), math.sin(angles[1])
        local cos_y, sin_y = math.cos(angles[2]), math.sin(angles[2])
        local cos_z, sin_z = math.cos(angles[3]), math.sin(angles[3])

        local rotation_x = {
            { 1, 0,     0,      0 },
            { 0, cos_x, -sin_x, 0 },
            { 0, sin_x, cos_x,  0 },
            { 0, 0,     0,      1 }
        }

        local rotation_y = {
            { cos_y,  0, sin_y, 0 },
            { 0,      1, 0,     0 },
            { -sin_y, 0, cos_y, 0 },
            { 0,      0, 0,     1 }
        }

        local rotation_z = {
            { cos_z, -sin_z, 0, 0 },
            { sin_z, cos_z,  0, 0 },
            { 0,     0,      1, 0 },
            { 0,     0,      0, 1 }
        }

        local function matrix_multiply_rot(a, b)
            local result = {}
            for i = 1, 4 do
                result[i] = {}
                for j = 1, 4 do
                    result[i][j] = 0
                    for k = 1, 4 do
                        result[i][j] = result[i][j] + a[i][k] * b[k][j]
                    end
                end
            end
            return result
        end

        local rotation_xy = matrix_multiply_rot(rotation_x, rotation_y)
        local rotation_xyz = matrix_multiply_rot(rotation_xy, rotation_z)
        return rotation_xyz
    end

    function matrix_multiply(m1, m2)
        local result = {}
        for i = 1, #m1 do
            result[i] = {}
        end

        for i = 1, #m1 do
            for j = 1, #m2[1] do
                local sum = 0
                for k = 1, #m1[i] do
                    sum = sum + m1[i][k] * m2[k][j]
                end
                result[i][j] = sum
            end
        end
        return result
    end

    -- Apply rotation to the array
    function rotate_array(array, rotation_matrix)
        local rotated_array = {}
        for i = 1, #array do
            local vector = { array[i][1], array[i][2], array[i][3] }
            local result = matrix_multiply({ vector }, rotation_matrix)
            rotated_array[i] = { result[1][1], result[1][2], result[1][3] }
        end
        return rotated_array
    end

    -- Improved transform and project function with proper fitting
  function transform_and_project_with_fit(array, translateX, translateY, translateZ, scaleX, scaleY, fov, aspect_ratio, near, far, fit_to_view, view_padding, coord_system)
    local result = {}
    
    if #array == 0 then
        return result
    end

    -- Normalize translation inputs to reasonable ranges
    local norm_translateX = translateX / 100.0
    local norm_translateY = translateY / 100.0
    local norm_translateZ = translateZ / 100.0

    -- First pass: apply scale and basic 3D translation
    local transformed_array = {}
    for i = 1, #array do
        local x = array[i][1] * scaleX
        local y = array[i][2] * scaleY
        local z = array[i][3] * scaleX  -- Using scaleX for Z if uniform scaling
        
        table.insert(transformed_array, {x, y, z})
    end

    -- Calculate auto-fit parameters if enabled
    local auto_translateZ = 0
    
    if fit_to_view then
        local bbox = calculate_bounding_box(transformed_array)
        
        -- Calculate the optimal distance to fit the object
        local fov_rad = fov * math.pi / 180
        local half_fov = fov_rad / 2
        
        -- Calculate required distance for width and height
        local width_dist = (bbox.width / 2) / (aspect_ratio * math.tan(half_fov))
        local height_dist = (bbox.height / 2) / math.tan(half_fov)
        
        -- Use the larger distance to ensure everything fits
        local optimal_distance = math.max(width_dist, height_dist)
        
        -- Add padding
        optimal_distance = optimal_distance * (1 + view_padding)
        
        -- Calculate center offset (we want the center of the object at (0,0) in screen space)
        local center_offset_z = bbox.center_z
        
        -- Set auto translation to position object at optimal distance
        auto_translateZ = -optimal_distance - center_offset_z
        
        -- Apply manual Z offset as a percentage of the auto distance
        auto_translateZ = auto_translateZ + (optimal_distance * norm_translateZ * 0.5)
    else
        -- Apply manual Z translation when not auto-fitting
        for i = 1, #transformed_array do
            transformed_array[i][3] = transformed_array[i][3] + norm_translateZ
        end
    end

    -- Helper function for perspective projection
    local function project(x, y, z)
        -- Apply auto-fit translation
        z = z + auto_translateZ
        
        -- Prevent division by zero or very small z values
        if z >= -near then
            z = -near - 0.001
        end
        
        local scale = 1 / math.tan(fov * 0.5 * math.pi / 180)
        local screen_x = (aspect_ratio * scale) * x / -z
        local screen_y = scale * y / -z
        return screen_x, screen_y
    end

    -- Second pass: project to screen coordinates and apply screen-space translation
    for i = 1, #transformed_array do
        local x, y, z = unpack(transformed_array[i])
        local screen_x, screen_y = project(x, y, z)

        -- Apply manual X/Y translation in screen space (after projection)
        screen_x = screen_x + norm_translateX
        screen_y = screen_y + norm_translateY

        -- Normalize coordinates based on coordinate system choice
        local normalized_x, normalized_y
        
        if coord_system == 0 then
            -- Standard [0,1] coordinate system
            normalized_x = (screen_x + 1) / 2  -- Convert from [-1, 1] to [0, 1]
            normalized_y = (screen_y + 1) / 2  -- Convert from [-1, 1] to [0, 1]
        else
            -- Centered [-0.5, 0.5] coordinate system (then shifted to [0,1])
            normalized_x = screen_x + 0.5  -- Convert from [-0.5, 0.5] to [0, 1]
            normalized_y = screen_y + 0.5  -- Convert from [-0.5, 0.5] to [0, 1]
        end
        
        table.insert(result, { normalized_x, normalized_y })
    end

    return result
end
    -- Apply transformations
    local angles = { math.rad(_rotationX), math.rad(_rotationY), math.rad(_rotationZ) }
    local rotation = rotation_matrix_XYZ(angles)
    local rotated_array = rotate_array(arrayA, rotation)
    
    local _transform_result = transform_and_project_with_fit(
        rotated_array, 
        _translateX, _translateY, _translateZ, 
        _scaleX, _scaleY, 
        fov, aspect_ratio, near, far,
        fit_to_view, view_padding, coord_system
    )

    local out_Array = {}
    out_Array["array"] = _transform_result
    out_Array["size"] = arrayutils.Length(_transform_result)

    local json_str_out = jsonutils.encode(out_Array)
    OutData:Set(req, Text(json_str_out))
end