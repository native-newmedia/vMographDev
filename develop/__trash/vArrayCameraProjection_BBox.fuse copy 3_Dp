-- ============================================================================
-- modules
-- ============================================================================
local jsonutils = self and require("vjsonutils") or nil
local arrayutils = self and require("varrayutils") or nil

-- ============================================================================
-- constants
-- ============================================================================
FUSE_NAME = "vArrayCameraProjection_BBox"
DATATYPE = "Text"

-- ============================================================================
-- fuse
-- ============================================================================
FuRegisterClass(FUSE_NAME, CT_Tool, {
    REGID_DataType = DATATYPE,
    REGID_InputDataType = DATATYPE,
    REG_NoCommonCtrls = true,
    REGS_Category = "Kartaverse\\Vonk Ultra\\Mograph\\Array\\Modify",
    REGS_Name = FUSE_NAME,
    REGS_OpDescription = "Transforms Array using a perspective projection matrix with improved fitting.",
    REGS_OpIconString = FUSE_NAME,
    REGS_IconID = "Icons.Tools.Icons.Camera3D",
})

function Create()
    -- Connection diagram
    local ConnectionLabel = [[
<table align="center" cellspacing="8">
  <tr>
    <td style="text-align: center; padding: 5px;">[vArray] →</td>
    <td style="text-align: center; background-color: #051626; color: white; padding: 5px; font-weight: bold;">[]]..FUSE_NAME..[[</td>
    <td style="text-align: center; padding: 5px;">→ [vArrayShapeRender]</td>
  </tr>
</table>]]

    InConnectionLabel = self:AddInput(ConnectionLabel, "ConnectionLabel", {
        LINKID_DataType = "Text",
        INPID_InputControl = "LabelControl",
        LBLC_MultiLine = true,
        INP_External = false,
        INP_Passive = true,
        IC_ControlPage = -1,
        IC_NoLabel = true,
        IC_NoReset = true,
    })

    -- Transform Controls
    self:BeginControlNest("Transform", "Transform", true, {LBLC_PickButton = false})
    
    -- Translation
    self:BeginControlNest("Translation", "Translation", false)
    TranslateX = self:AddInput("X Offset", "Translate.X", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Integer = false,
        INP_MinScale = -2.0,
        INP_MaxScale = 2.0,
        INP_Default = 0.0,
    })
    TranslateY = self:AddInput("Y Offset", "Translate.Y", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Integer = false,
        INP_MinScale = -2.0,
        INP_MaxScale = 2.0,
        INP_Default = 0.0,
    })
    TranslateZ = self:AddInput("Z Offset", "Translate.Z", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Integer = false,
        INP_MinScale = -2.0,
        INP_MaxScale = 2.0,
        INP_Default = 0.0,
    })
    self:EndControlNest()
    
    -- Rotation
    self:BeginControlNest("Rotation", "Rotation", false)
    InRotOrder = self:AddInput("Rotation Order", "RotOrder", {
        LINKID_DataType = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default = 0,
        {MBTNC_AddButton = "XYZ", MBTNC_AddButtonID = "0"},
        {MBTNC_AddButton = "XZY", MBTNC_AddButtonID = "1"},
        {MBTNC_AddButton = "YXZ", MBTNC_AddButtonID = "2"},
        {MBTNC_AddButton = "YZX", MBTNC_AddButtonID = "3"},
        {MBTNC_AddButton = "ZXY", MBTNC_AddButtonID = "4"},
        {MBTNC_AddButton = "ZYX", MBTNC_AddButtonID = "5"},
    })
    RotateX = self:AddInput("X Rotation", "Rotate.X", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_MaxScale = 360.0,
        INP_Default = 0.0,
    })
    RotateY = self:AddInput("Y Rotation", "Rotate.Y", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_MaxScale = 360.0,
        INP_Default = 0.0,
    })
    RotateZ = self:AddInput("Z Rotation", "Rotate.Z", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_MaxScale = 360.0,
        INP_Default = 0.0,
    })
    self:EndControlNest()
    
    -- Scale
    self:BeginControlNest("Scale", "Scale", false)
    InLockScale = self:AddInput("Lock X/Y", "LockXY", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 1,
        INP_DoNotifyChanged = true,
    })
    ScaleX = self:AddInput("Scale", "Scale.X", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Integer = false,
        INP_Default = 1.0,
        INP_MinScale = 0.01,
        INP_MaxScale = 10.0,
    })
    ScaleY = self:AddInput("Y Scale", "Scale.Y", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Integer = false,
        INP_Default = 1.0,
        INP_MinScale = 0.01,
        INP_MaxScale = 10.0,
        IC_Visible = false,
        PC_Visible = false
    })
    self:EndControlNest()
    
    self:EndControlNest() -- End Transform nest

    -- Camera Controls
    self:BeginControlNest("Camera", "Camera", true, {LBLC_PickButton = false})
    InFov = self:AddInput("Field of View", "fov", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Integer = false,
        INP_Default = 60.0,
        INP_MinScale = 1.0,
        INP_MaxScale = 179.0,
    })
    
    InFitToView = self:AddInput("Auto Fit", "FitToView", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 1,
    })
    
    InViewPadding = self:AddInput("Padding", "ViewPadding", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Integer = false,
        INP_Default = 0.1,
        INP_MinScale = 0.0,
        INP_MaxScale = 0.5,
    })
    
    InCoordSystem = self:AddInput("Coordinate System", "CoordSystem", {
        LINKID_DataType = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default = 0,
        {MBTNC_AddButton = "Standard [0,1]", MBTNC_AddButtonID = "0"},
        {MBTNC_AddButton = "Centered [0,1]", MBTNC_AddButtonID = "1"},
    })
    
    -- Advanced (hidden by default)
    self:BeginControlNest("Advanced", "Advanced", false, {
        LBLC_PickButton = true,
        ICS_ControlPage = "Camera",
        IC_Visible = false,
        PC_Visible = false
    })
    InAspectRatio = self:AddInput("Aspect Ratio", "aspect_ratio", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 16/9,
    })
    InNear = self:AddInput("Near Clip", "near", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 0.1,
        INP_MinScale = 0.001,
    })
    InFar = self:AddInput("Far Clip", "far", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 1000.0,
    })
    self:EndControlNest()
    
    self:EndControlNest() -- End Camera nest

    -- Main IO
    InArray = self:AddInput("Array", "ArrayA", {
        LINKID_DataType = DATATYPE,
        LINK_Main = 1,
        INPID_InputControl = "ImageControl",
    })

    OutData = self:AddOutput("Output", "Output", {
        LINKID_DataType = DATATYPE,
        LINK_Main = 1,
    })
end

function NotifyChanged(inp, param, time)
    if inp == InLockScale then
        local locked = param.Value > 0.5
        ScaleX:SetAttrs({LINKS_Name = locked and "Scale" or "X Scale"})
        ScaleY:SetAttrs({IC_Visible = not locked, PC_Visible = not locked})
    end
end

-- ============================================================================
-- Math Utilities
-- ============================================================================
local function mat4_mult(a, b)
    local res = {}
    for i = 1, 4 do
        res[i] = {}
        for j = 1, 4 do
            res[i][j] = 0
            for k = 1, 4 do
                res[i][j] = res[i][j] + a[i][k] * b[k][j]
            end
        end
    end
    return res
end

local function transform_point(x, y, z, mat)
    local w = mat[4][1] * x + mat[4][2] * y + mat[4][3] * z + mat[4][4]
    local tx = (mat[1][1] * x + mat[1][2] * y + mat[1][3] * z + mat[1][4]) / w
    local ty = (mat[2][1] * x + mat[2][2] * y + mat[2][3] * z + mat[2][4]) / w
    local tz = (mat[3][1] * x + mat[3][2] * y + mat[3][3] * z + mat[3][4]) / w
    return tx, ty, tz
end

local function translation_matrix(tx, ty, tz)
    return {
        {1, 0, 0, tx},
        {0, 1, 0, ty},
        {0, 0, 1, tz},
        {0, 0, 0, 1}
    }
end

local function scale_matrix(sx, sy, sz)
    return {
        {sx, 0,  0,  0},
        {0,  sy, 0,  0},
        {0,  0,  sz, 0},
        {0,  0,  0,  1}
    }
end

local function rotation_matrix(angles, order)
    local rx, ry, rz = angles[1], angles[2], angles[3]
    local cosx, sinx = math.cos(rx), math.sin(rx)
    local cosy, siny = math.cos(ry), math.sin(ry)
    local cosz, sinz = math.cos(rz), math.sin(rz)
    
    local rot_x = {
        {1, 0,    0,     0},
        {0, cosx, -sinx, 0},
        {0, sinx, cosx,  0},
        {0, 0,    0,     1}
    }
    
    local rot_y = {
        {cosy,  0, siny, 0},
        {0,     1, 0,    0},
        {-siny, 0, cosy, 0},
        {0,     0, 0,    1}
    }
    
    local rot_z = {
        {cosz, -sinz, 0, 0},
        {sinz, cosz,  0, 0},
        {0,    0,     1, 0},
        {0,    0,     0, 1}
    }
    
    local rot_order = {
        XYZ = function() return mat4_mult(mat4_mult(rot_x, rot_y), rot_z) end,
        XZY = function() return mat4_mult(mat4_mult(rot_x, rot_z), rot_y) end,
        YXZ = function() return mat4_mult(mat4_mult(rot_y, rot_x), rot_z) end,
        YZX = function() return mat4_mult(mat4_mult(rot_y, rot_z), rot_x) end,
        ZXY = function() return mat4_mult(mat4_mult(rot_z, rot_x), rot_y) end,
        ZYX = function() return mat4_mult(mat4_mult(rot_z, rot_y), rot_x) end
    }
    
    return rot_order[order]()
end

local function calculate_bounding_box(points, padding)
    if #points == 0 then return {min_x=0, max_x=0, min_y=0, max_y=0, min_z=0, max_z=0} end
    
    local min_x, max_x = points[1][1], points[1][1]
    local min_y, max_y = points[1][2], points[1][2]
    local min_z, max_z = points[1][3], points[1][3]
    
    for i = 1, #points do
        min_x = math.min(min_x, points[i][1])
        max_x = math.max(max_x, points[i][1])
        min_y = math.min(min_y, points[i][2])
        max_y = math.max(max_y, points[i][2])
        min_z = math.min(min_z, points[i][3])
        max_z = math.max(max_z, points[i][3])
    end
    
    if padding then
        min_x = min_x - padding
        max_x = max_x + padding
        min_y = min_y - padding
        max_y = max_y + padding
        min_z = min_z - padding
        max_z = max_z + padding
    end
    
    return {
        min_x = min_x, max_x = max_x,
        min_y = min_y, max_y = max_y,
        min_z = min_z, max_z = max_z,
        width = max_x - min_x,
        height = max_y - min_y,
        depth = max_z - min_z,
        center_x = (min_x + max_x)/2,
        center_y = (min_y + max_y)/2,
        center_z = (min_z + max_z)/2
    }
end

local function compute_auto_zoom(bbox, fov, aspect, padding)
    local fov_rad = fov * math.pi / 180
    local half_fov = fov_rad / 2
    
    local width_dist = (bbox.width / 2) / (aspect * math.tan(half_fov))
    local height_dist = (bbox.height / 2) / math.tan(half_fov)
    
    local optimal_distance = math.max(width_dist, height_dist)
    optimal_distance = optimal_distance * (1 + (padding or 0))
    
    return -optimal_distance - bbox.center_z
end

local function perspective_project(x, y, z, fov, aspect, near)
    if z >= -near then z = -near - 0.001 end
    
    local f = 1.0 / math.tan(fov * 0.5 * math.pi / 180)
    local sx = (f * aspect) * x / -z
    local sy = f * y / -z
    
    return sx, sy
end

local function transform_array(points, transform_fn)
    local result = {}
    for i = 1, #points do
        result[i] = {transform_fn(points[i][1], points[i][2], points[i][3])}
    end
    return result
end

-- ============================================================================
-- Main Processing
-- ============================================================================
function Process(req)
    -- Input validation
    local arrayA = InArray:GetValue(req)
    if not arrayA or not arrayA.Value then
        OutData:Set(req, Text(jsonutils.encode({array = {}, size = 0})))
        return
    end
    
    local data = jsonutils.decode(arrayA.Value)
    if not data or not data.array then
        OutData:Set(req, Text(jsonutils.encode({array = {}, size = 0})))
        return
    end
    
    -- Get control values
    local tx = TranslateX:GetValue(req).Value
    local ty = TranslateY:GetValue(req).Value
    local tz = TranslateZ:GetValue(req).Value
    
    local r_order = {"XYZ", "XZY", "YXZ", "YZX", "ZXY", "ZYX"}


    local rot_order = "XYZ" -- InRotOrder:GetValue(req).Value + 1
    local rx = math.rad(RotateX:GetValue(req).Value)
    local ry = math.rad(RotateY:GetValue(req).Value)
    local rz = math.rad(RotateZ:GetValue(req).Value)
    
    local sx = ScaleX:GetValue(req).Value
    local sy = InLockScale:GetValue(req).Value > 0.5 and sx or ScaleY:GetValue(req).Value
    
    local fov = InFov:GetValue(req).Value
    local aspect = InAspectRatio:GetValue(req).Value
    local near = InNear:GetValue(req).Value
    local far = InFar:GetValue(req).Value
    local fit_to_view = InFitToView:GetValue(req).Value > 0.5
    local padding = InViewPadding:GetValue(req).Value
    local coord_system = InCoordSystem:GetValue(req).Value
    
    -- Create transformation matrix
    local rot_mat = rotation_matrix({rx, ry, rz}, rot_order)
    local scale_mat = scale_matrix(sx, sy, sx)  -- Uniform Z scale
    local transform_mat = mat4_mult(rot_mat, scale_mat)
    
    -- Apply transformations
    local transformed = transform_array(data.array, function(x, y, z)
        return transform_point(x, y, z, transform_mat)
    end)
    
    -- Calculate auto-fit Z offset
    local auto_z = 0
    if fit_to_view then
        local bbox = calculate_bounding_box(transformed, padding)
        auto_z = compute_auto_zoom(bbox, fov, aspect, padding)
        -- Apply manual Z adjustment as percentage of auto distance
        auto_z = auto_z + (math.abs(auto_z) * tz * 0.5)
    else
        -- Manual Z translation in 3D space
        for i = 1, #transformed do
            transformed[i][3] = transformed[i][3] + tz
        end
    end
    
    -- Project to screen space
    local projected = {}
    for i = 1, #transformed do
        local x, y, z = unpack(transformed[i])
        local sx, sy = perspective_project(x, y, z + auto_z, fov, aspect, near)
        
        -- Apply screen-space translation
        sx = sx + tx
        sy = sy + ty
        
        -- Convert to output coordinate system
        if coord_system == 0 then
            -- Standard [0,1]
            sx = (sx + 1) / 2
            sy = (sy + 1) / 2
        else
            -- Centered [0,1]
            sx = sx + 0.5
            sy = sy + 0.5
        end
        
        projected[i] = {sx, sy}
    end
    
    -- Output result
    OutData:Set(req, Text(jsonutils.encode({
        array = projected,
        size = #projected
    })))
end