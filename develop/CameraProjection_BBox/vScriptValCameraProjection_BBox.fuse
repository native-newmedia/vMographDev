-- vJSONTransform renamed to vJSONCameraProjection
-- ============================================================================
-- modules
-- ============================================================================
local jsonutils = self and require("vjsonutils") or nil
local arrayutils = self and require("varrayutils") or nil

-- ============================================================================
-- constants
-- ============================================================================
FUSE_NAME = "vScriptValCameraProjection_BBox"
DATATYPE = "ScriptVal"

-- ============================================================================
-- fuse
-- ============================================================================
FuRegisterClass(FUSE_NAME, CT_Tool, {
    REGID_DataType = DATATYPE,
    REGID_InputDataType = DATATYPE,
    REG_NoCommonCtrls = true,
    REGS_Category = "Kartaverse\\Vonk Ultra\\Mograph\\ScriptVal\\Modify",
    REGS_Name = FUSE_NAME,
    REGS_OpDescription = "Transforms ScriptVals using a perspective projection matrix.",
    REGS_OpIconString = FUSE_NAME,
    REGS_IconID = "Icons.Tools.Icons.Camera3D",
})

function Create()
    -- [[ Creates the user interface. ]]
    local ConnectionLabel = [[
<table align="center" cellspacing="8">
  <tr>
  <td style="text-align: center; padding: 5px;">[vScriptVal] →</td>
    <td style="text-align: center; background-color: #051626; color: white; padding: 5px; font-weight: bold;">[]] ..
        FUSE_NAME .. [[]</td>
    <td style="text-align: center; padding: 5px;">→ [vScriptValRender]</td>
  </tr>
</table>
]]

    InConnectionLabel = self:AddInput(ConnectionLabel, "ConnectionLabel", {
        LINKID_DataType = "Text",
        INPID_InputControl = "LabelControl",
        LBLC_MultiLine = true,
        INP_External = false,
        INP_Passive = true,
        IC_ControlPage = -1,
        IC_NoLabel = true,
        IC_NoReset = true,
    })
    self:BeginControlNest("Translation", "Translation", true, { LBLC_PickButton = false })

    TranslateX = self:AddInput("X Offset", "Translate.X", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
    })

    TranslateY = self:AddInput("Y Offset", "Translate.Y", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
    })

    TranslateZ = self:AddInput("Z Offset", "Translate.Z", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 1.0,
    })
    self:EndControlNest()

    self:BeginControlNest("Rotation", "Rotation", true, { LBLC_PickButton = false })
    InRotOrder = self:AddInput("Rotation Order", "RotOrder", {
        LINKID_DataType = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default = 0,
        { MBTNC_AddButton = " XYZ ", },
        { MBTNC_AddButton = " XZY ", },
        { MBTNC_AddButton = " YXZ ", },
        { MBTNC_AddButton = " YZX ", },
        { MBTNC_AddButton = " ZXY ", },
        { MBTNC_AddButton = " ZYX ", },
        IC_Visible = false,
        PC_Visible = false
    })

    RotateX = self:AddInput("X Rotation", "Rotate.X", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_MaxScale = 360.0,
        IC_Steps = 1,
    })

    RotateY = self:AddInput("Y Rotation", "Rotate.Y", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_MaxScale = 360.0,
        IC_Steps = 1,
    })

    RotateZ = self:AddInput("Z Rotation", "Rotate.Z", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_MaxScale = 360.0,
    })

    self:EndControlNest()
    self:BeginControlNest("Scale", "Scale", true, { LBLC_PickButton = false })
    InLockScale = self:AddInput("Lock X/Y", "LockXY", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 1,
        INP_DoNotifyChanged = true,
    })

    ScaleX = self:AddInput("X Scale", "Scale.X", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 1.0,
    })

    ScaleY = self:AddInput("Y Scale", "Scale.Y", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 1.0,
        IC_Visible = false,
        PC_Visible = false
    })
    self:EndControlNest()

    self:BeginControlNest("perspective projection", "perspective_projection", true, {
        LBLC_PickButton = false,
    })
    InFov = self:AddInput("Field of view", "fov", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Integer = false,
        INP_Default = 90.0,
    })
    InAspect_ratio = self:AddInput("Screen aspect ratio", "aspect_ratio", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 16 / 9,
        IC_Visible = false,
        PC_Visible = false
    })

    InNear = self:AddInput("Near clipping plane", "near", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 0.1,
        IC_Visible = false,
        PC_Visible = false
    })
    InFar = self:AddInput("Far clipping plane", "for", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 1000,
        IC_Visible = false,
        PC_Visible = false
    })

    self:EndControlNest()

    self:BeginControlNest("Shear", "Shear", true, {
        LBLC_PickButton = false,
        IC_Visible = false,
        PC_Visible = false
    })
    ShearX = self:AddInput("X Shear", "Shear.X", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 0.0,
        IC_Visible = false,
        PC_Visible = false
    })

    ShearY = self:AddInput("Y Shear", "Shear.Y", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ScrewControl",
        INP_Integer = false,
        INP_Default = 0.0,
        IC_Visible = false,
        PC_Visible = false

    })
    self:EndControlNest()

    -- ===================================================================NEW
    -- Add these to your FuRegisterClass section where you define inputs

    -- Fit to BBox Button
    InFitToBBox = self:AddInput("Fit to BBox", "FitToBBox", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_DoNotifyChanged = true,
        INP_Integer = true,
        INP_Default = 0.0,
        INP_External = false,
    })

    -- Padding Parameter
    InPadding = self:AddInput("Padding", "Padding", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 1.2,
        INP_MinScale = 0.01,
        INP_MaxScale = 10.0,
        INP_MinAllowed = -1e+38,
        INP_MaxAllowed = 1e+38,
        INP_External = false,
        INP_DoNotifyChanged = true,
    })

    -- Preserve Z Distance Option
    InPreserveZ = self:AddInput("Preserve Z Distance", "PreserveZ", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0,
        INP_External = false,
        IC_Visible = false,
        PC_Visible = false,
    })

    -- Adjust Scale Option
    InAdjustScale = self:AddInput("Adjust Scale", "AdjustScale", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0,
        INP_External = false,
        IC_Visible = false,
        PC_Visible = false,
    })

    -- Add a separator for the viewpoint presets section
    ViewpointPresets = self:AddInput("Viewpoint Presets", "ViewpointPresetsLabel", {
        LINKID_DataType = "Text",
        INPID_InputControl = "LabelControl",
        INP_External = false,
    })

    -- Add viewpoint preset buttons
    InViewFront = self:AddInput("Front View", "ViewFront", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0,
        INP_DoNotifyChanged = true,
        INP_External = false,
    })

    InViewTop = self:AddInput("Top View", "ViewTop", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0,
        INP_DoNotifyChanged = true,
        INP_External = false,
    })

    InViewRight = self:AddInput("Right View", "ViewRight", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0,
        INP_DoNotifyChanged = true,
        INP_External = false,
    })

    InViewIsometric = self:AddInput("Isometric View", "ViewIsometric", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_DoNotifyChanged = true,
        INP_External = false,
        INP_Default = 0,
        IC_Visible = false,
        PC_Visible = false
    })

    InViewPerspective = self:AddInput("Persp View", "ViewPerspective", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0,
        INP_DoNotifyChanged = true,
        INP_External = false,
        IC_Visible = false,
        PC_Visible = false
    })
    -- ===================================================================NEW

    InShowInput = self:AddInput("Show Input", "ShowInput", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 1.0,
        INP_External = false,
        INP_DoNotifyChanged = true
    })
    InScriptVal = self:AddInput("ScriptVal", "ScriptVal", {
        LINKID_DataType = "ScriptVal",
        LINK_Main = 1
    })

    OutScriptVal = self:AddOutput("Output", "Output", {
        LINKID_DataType = "ScriptVal",
        LINK_Main = 1,
    })
end

function NotifyChanged(inp, param, time)
    if inp == InPadding then
        InFitToBBox:SetSource(Number(1), 0, time)
        -- print("Padding changed to: " .. param.Value)
    end



    if inp == InLockScale then
        if param.Value > 0.5 then
            ScaleX:SetAttrs({ LINKS_Name = "Scale" })
            ScaleY:SetAttrs({ IC_Visible = false, PC_Visible = false })
        else
            ScaleX:SetAttrs({ LINKS_Name = "X Scale" })
            ScaleY:SetAttrs({ IC_Visible = true, PC_Visible = true })
        end
    end
end

function convertY(y, ref_img)
    return y * (ref_img.Height * ref_img.YScale) / (ref_img.Width * ref_img.XScale)
end

-- ===================================================================NEW
-- Calculate the bounding box of the input points
function calculate_bounding_box(points, rotation_matrix)
    if #points == 0 then
        return { min_x = 0, max_x = 0, min_y = 0, max_y = 0, min_z = 0, max_z = 0 }
    end

    -- Apply rotation to get orientation-aware bounding box
    local rotated_points = points
    if rotation_matrix then
        rotated_points = rotate_array(points, rotation_matrix)
    end

    local min_x, max_x = rotated_points[1][1], rotated_points[1][1]
    local min_y, max_y = rotated_points[1][2], rotated_points[1][2]
    local min_z, max_z = rotated_points[1][3], rotated_points[1][3]

    for i = 2, #rotated_points do
        -- X coordinate
        if rotated_points[i][1] < min_x then min_x = rotated_points[i][1] end
        if rotated_points[i][1] > max_x then max_x = rotated_points[i][1] end

        -- Y coordinate
        if rotated_points[i][2] < min_y then min_y = rotated_points[i][2] end
        if rotated_points[i][2] > max_y then max_y = rotated_points[i][2] end

        -- Z coordinate
        if rotated_points[i][3] < min_z then min_z = rotated_points[i][3] end
        if rotated_points[i][3] > max_z then max_z = rotated_points[i][3] end
    end

    return {
        min_x = min_x,
        max_x = max_x,
        min_y = min_y,
        max_y = max_y,
        min_z = min_z,
        max_z = max_z,
        original_points = points,
        rotated_points = rotated_points
    }
end

-- Enhanced fit to view function with the requested improvements
function fit_to_view(points, fov, aspect_ratio, padding, preserve_z, adjust_scale, rotation_matrix)
    -- Calculate the bounding box with orientation awareness
    local bbox = calculate_bounding_box(points, rotation_matrix)

    -- Calculate the center of the bounding box
    local center_x = (bbox.min_x + bbox.max_x) / 2
    local center_y = (bbox.min_y + bbox.max_y) / 2
    local center_z = (bbox.min_z + bbox.max_z) / 2

    -- Calculate the dimensions of the bounding box
    local width = bbox.max_x - bbox.min_x
    local height = bbox.max_y - bbox.min_y
    local depth = bbox.max_z - bbox.min_z

    -- Consider asymmetric objects by checking aspect ratio
    local screen_aspect = aspect_ratio
    local object_aspect = width / height

    local scale_factor = 1.0
    local translate_z = 0

    -- Handle both horizontal and vertical fitting based on aspect ratios
    if object_aspect > screen_aspect then
        -- Object is wider than screen
        local distance = (width / 2) / math.tan(math.rad(fov / 2))
        translate_z = -distance - center_z
    else
        -- Object is taller than screen
        local vertical_fov = fov / screen_aspect
        local distance = (height / 2) / math.tan(math.rad(vertical_fov / 2))
        translate_z = -distance - center_z
    end

    -- Apply the padding factor
    translate_z = translate_z * padding

    -- Calculate scale adjustment if requested
    if adjust_scale then
        -- Determine ideal scale based on view size and object size
        local ideal_scale = 0.8 / math.max(width, height * aspect_ratio)
        scale_factor = ideal_scale
    end

    -- If preserve_z is true, use the current Z value
    if preserve_z then
        translate_z = nil -- Will be ignored in the caller
    end

    -- Return the new translation values and scale factor
    return -center_x, -center_y, translate_z, scale_factor
end

-- Add viewpoint preset function
function set_viewpoint_preset(preset, points)
    -- Define rotation angles for different presets (in radians)
    local presets = {
        front = { 0, 0, 0 },           -- Front view (0,0,0)
        top = { 90, 0, 0 },            -- Top view (90,0,0)
        right = { 0, 90, 0 },          -- Right view (0,90,0)
        left = { 0, -90, 0 },          -- Left view (0,-90,0)
        bottom = { -90, 0, 0 },        -- Bottom view (-90,0,0)
        back = { 0, 180, 0 },          -- Back view (0,180,0)
        isometric = { 35.264, 45, 0 }, -- Isometric view (35.264,45,0)
        perspective = { 30, 45, 10 }   -- Perspective view (30,45,10)
    }

    -- Get the rotation angles for the requested preset
    local angles = presets[preset:lower()]
    if not angles then
        return nil, nil, nil, nil, nil -- Preset not found
    end

    -- Create rotation matrix for this preset
    local rotation = rotation_matrix_XYZ(angles)

    -- Return the rotation angles and matrix
    return angles[1], angles[2], angles[3], rotation, preset
end

-- =========================Rotation Setup =================================

function rotation_matrix_XYZ(angles)
    local cos_x, sin_x = math.cos(angles[1]), math.sin(angles[1])
    local cos_y, sin_y = math.cos(angles[2]), math.sin(angles[2])
    local cos_z, sin_z = math.cos(angles[3]), math.sin(angles[3])

    -- Rotation matrix around X-axis
    local rotation_x = {
        { 1, 0,     0,      0 },
        { 0, cos_x, -sin_x, 0 },
        { 0, sin_x, cos_x,  0 },
        { 0, 0,     0,      1 }
    }

    -- Rotation matrix around Y-axis
    local rotation_y = {
        { cos_y,  0, sin_y, 0 },
        { 0,      1, 0,     0 },
        { -sin_y, 0, cos_y, 0 },
        { 0,      0, 0,     1 }
    }

    -- Rotation matrix around Z-axis
    local rotation_z = {
        { cos_z, -sin_z, 0, 0 },
        { sin_z, cos_z,  0, 0 },
        { 0,     0,      1, 0 },
        { 0,     0,      0, 1 }
    }

    -- Function to multiply two 4x4 matrices
    local function matrix_multiply_rot(a, b)
        local result = {}
        for i = 1, 4 do
            result[i] = {}
            for j = 1, 4 do
                result[i][j] = 0
                for k = 1, 4 do
                    result[i][j] = result[i][j] + a[i][k] * b[k][j]
                end
            end
        end
        return result
    end

    -- Combine the rotation matrices
    local rotation_xy = matrix_multiply_rot(rotation_x, rotation_y)
    local rotation_xyz = matrix_multiply_rot(rotation_xy, rotation_z)

    return rotation_xyz
end

-- ================================================================================

-- Apply rotation to the array
function rotate_array(array, rotation_matrix)
    local rotated_array = {}
    for i = 1, #array do
        local vector = { array[i][1], array[i][2], array[i][3] }
        local result = matrix_multiply({ vector }, rotation_matrix)
        rotated_array[i] = { result[1][1], result[1][2], result[1][3] }
    end

    return rotated_array
end

-- Define functions to create transformation matrices
function translation_matrix(tx, ty, tz)
    return {
        { 1, 0, 0, tx },
        { 0, 1, 0, ty },
        { 0, 0, 1, tz },
        { 0, 0, 0, 1 }
    }
end

function scale_matrix(sx, sy, sz)
    return {
        { sx, 0,  0,  0 },
        { 0,  sy, 0,  0 },
        { 0,  0,  sz, 0 },
        { 0,  0,  0,  1 }
    }
end

-- Function to perform matrix multiplication
function matrix_multiply(m1, m2)
    -- Initialize result table with sub-tables
    local result = {}
    for i = 1, #m1 do
        result[i] = {}
    end

    -- Perform matrix multiplication
    for i = 1, #m1 do
        for j = 1, #m2[1] do
            local sum = 0
            for k = 1, #m1[i] do
                sum = sum + m1[i][k] * m2[k][j]
            end
            result[i][j] = sum
        end
    end
    return result
end

-- ==================Projection Setup =================================

-- Function to convert 3D world coordinates to 2D screen coordinates
function project(x, y, z, fov, aspect_ratio, near, far)
    -- Perspective projection matrix components
    local scale = 1 / math.tan(fov * 0.5 * math.pi / 180)

    -- Projection matrix components
    local a = aspect_ratio * scale
    local b = scale
    local c = far / (far - near)
    local d = (-far * near) / (far - near)

    -- Apply perspective projection
    local screen_x = a * x / -z
    local screen_y = b * y / -z

    return screen_x, screen_y
end

-- ================================================


-- ===================================================================NEW

function Process(req)
    -- [[ Creates the output. ]]
    local arrayA = InScriptVal:GetValue(req):GetValue() or {}

    -- Get the button state for Fit to BBox
    local fit_to_bbox = InFitToBBox:GetValue(req).Value
    local padding = InPadding:GetValue(req).Value
    local preserve_z = InPreserveZ:GetValue(req).Value > 0.5
    local adjust_scale = InAdjustScale:GetValue(req).Value > 0.5

    -- Get the viewpoint preset buttons
    local viewpoint_front = InViewFront:GetValue(req).Value
    local viewpoint_top = InViewTop:GetValue(req).Value
    local viewpoint_right = InViewRight:GetValue(req).Value
    local viewpoint_isometric = InViewIsometric:GetValue(req).Value
    local viewpoint_perspective = InViewPerspective:GetValue(req).Value

    local _translateX = TranslateX:GetValue(req).Value
    local _translateY = TranslateY:GetValue(req).Value
    local _translateZ = TranslateZ:GetValue(req).Value

    local _rotationX = RotateX:GetValue(req).Value
    local _rotationY = RotateY:GetValue(req).Value
    local _rotationZ = RotateZ:GetValue(req).Value

    local _scaleX = ScaleX:GetValue(req).Value
    local _scaleY = ScaleY:GetValue(req).Value

    if InLockScale:GetValue(req).Value < 0.5 then
        _scaleX = ScaleX:GetValue(req).Value
        _scaleY = ScaleY:GetValue(req).Value
    end

    -- Handle viewpoint preset changes
    local preset_activated = false
    local preset_name = ""
    local rotation_preset = nil

    if viewpoint_front > 0.5 then
        _rotationX, _rotationY, _rotationZ, rotation_preset, preset_name = set_viewpoint_preset("front", arrayA)
        preset_activated = true
        InViewFront:SetSource(Number(0), 0, req) -- reset CheckboxControl
    elseif viewpoint_top > 0.5 then
        _rotationX, _rotationY, _rotationZ, rotation_preset, preset_name = set_viewpoint_preset("top", arrayA)
        preset_activated = true
        InViewTop:SetSource(Number(0), 0, req) -- reset CheckboxControl
    elseif viewpoint_right > 0.5 then
        _rotationX, _rotationY, _rotationZ, rotation_preset, preset_name = set_viewpoint_preset("right", arrayA)
        preset_activated = true
        InViewRight:SetSource(Number(0), 0, req) -- reset CheckboxControl
    elseif viewpoint_isometric > 0.5 then
        _rotationX, _rotationY, _rotationZ, rotation_preset, preset_name = set_viewpoint_preset("isometric", arrayA)
        preset_activated = true
        InViewIsometric:SetSource(Number(0), 0, req) -- reset CheckboxControl
    elseif viewpoint_perspective > 0.5 then
        _rotationX, _rotationY, _rotationZ, rotation_preset, preset_name = set_viewpoint_preset("perspective", arrayA)
        preset_activated = true
        InViewPerspective:SetSource(Number(0), 0, req) -- reset CheckboxControl
    end

    -- Update rotation inputs if a preset was selected
    if preset_activated then
        RotateX:SetSource(Number(_rotationX), 0, req)
        RotateY:SetSource(Number(_rotationY), 0, req)
        RotateZ:SetSource(Number(_rotationZ), 0, req)
    end

    -- Create the rotation matrix from current angles
    local angles = { math.rad(_rotationX), math.rad(_rotationY), math.rad(_rotationZ) }
    local rotation = rotation_matrix_XYZ(angles)

    -- Check if the Fit to BBox button was pressed
    if fit_to_bbox > 0.5 or preset_activated then
        -- If button is pressed, calculate the optimal translation values

        local fov = InFov:GetValue(req).Value
        local aspect_ratio = InAspect_ratio:GetValue(req).Value

        -- Only perform fit if we have valid input data
        if #arrayA > 0 then
            local new_translateX, new_translateY, new_translateZ, scale_factor =
                fit_to_view(arrayA, fov, aspect_ratio, padding, preserve_z, adjust_scale, rotation)

            -- Apply new translations
            _translateX = new_translateX
            _translateY = new_translateY

            -- Only update Z if not preserving current Z
            if not preserve_z and new_translateZ then
                _translateZ = new_translateZ
            end

            -- Apply scale adjustment if requested
            if adjust_scale and scale_factor then
                _scaleX = scale_factor
                _scaleY = scale_factor

                -- Update scale inputs
                ScaleX:SetSource(Number(_scaleX), 0, req)
                ScaleY:SetSource(Number(_scaleY), 0, req)
            end

            -- Update the input controls to reflect the new values
            TranslateX:SetSource(Number(_translateX), 0, req)
            TranslateY:SetSource(Number(_translateY), 0, req)
            TranslateZ:SetSource(Number(_translateZ), 0, req)
        end

        InFitToBBox:SetSource(Number(0), 0, req) -- reset CheckboxControl
    end


    local _shearX = ShearX:GetValue(req).Value
    local _shearY = ShearY:GetValue(req).Value



    local fov = InFov:GetValue(req).Value
    local aspect_ratio = InAspect_ratio:GetValue(req).Value
    local near = InNear:GetValue(req).Value
    local far = InFar:GetValue(req).Value


    local result = {}


    -- Function to perform matrix transformation and project to 2D screen coordinates with normalization
    function transform_and_project(array, translateX, translateY, translateZ, scaleX, scaleY, fov, aspect_ratio, near,
                                   far)
        local result = {}

        -- Helper function for perspective projection
        local function project(x, y, z)
            local scale = 1 / math.tan(fov * 0.5 * math.pi / 180)
            local screen_x = (aspect_ratio * scale) * x / -z
            local screen_y = scale * y / -z
            return screen_x, screen_y
        end

        for i = 1, #array do
            local transformed = {}
            for j = 1, #array[i] do
                local value = array[i][j]

                -- Translate
                if j == 1 then
                    value = value + translateX
                elseif j == 2 then
                    value = value + translateY
                elseif j == 3 then
                    value = value + translateZ
                end

                -- Scale
                if j == 1 then
                    value = value * scaleX
                elseif j == 2 then
                    value = value * scaleY
                else
                    value = value * scaleX
                end

                table.insert(transformed, value)
            end

            -- Apply perspective projection
            local x, y, z = unpack(transformed)
            local screen_x, screen_y = project(x, y, z)

            -- Normalize the coordinates
            -- Assuming the screen coordinates are in the range (-aspect_ratio, aspect_ratio) for x and (-1, 1) for y
            -- print( screen_y * (1080 * 1) / (1920 * 1),"<---------------------->",(screen_y / 2) + 0.25)

            local normalized_x = (screen_x / (aspect_ratio * 2)) + 0.5
            local normalized_y = (screen_y / 2) + 0.25 ---Fix this

            table.insert(result, { normalized_x, normalized_y })
        end

        return result
    end

    -- ================================================================================

    -- Rotate around X, Y, Z
    local angles            = { math.rad(_rotationX), math.rad(_rotationY), math.rad(_rotationZ) }
    local rotation          = rotation_matrix_XYZ(angles)

    local rotated_array     = rotate_array(arrayA, rotation)
    local _transform_result = transform_and_project(rotated_array, _translateX, _translateY, _translateZ, _scaleX,
        _scaleY, fov, aspect_ratio, near, far)

    OutScriptVal:Set(req, ScriptValParam(_transform_result))
end
