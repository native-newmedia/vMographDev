-- ============================================================================
-- modules
-- ============================================================================
local utf8 = require("utf8")
local chance = require("chance")
-- local jsonutils = self and require("vjsonutils") or nil
-- local arrayutils = self and require("varrayutils") or nil
-- ============================================================================
-- constants
-- ============================================================================
FUSE_NAME = "vArrayShapeText"
DATATYPE = "ScriptVal"
-- ============================================================================
-- fuse
-- ============================================================================
FuRegisterClass(FUSE_NAME, CT_Tool, {
	REGID_DataType      = DATATYPE,
	REGID_InputDataType = DATATYPE,
	REGS_Category       = "Kartaverse\\Vonk Ultra\\Mograph\\Array\\Shape",
	REGS_Name           = FUSE_NAME,
	REGS_OpDescription  = "Example, using Text and Strings",
	REGS_IconID         = "Icons.Tools.Icons.sRender",
	REG_Version         = 100,
	REG_TimeVariant     = true, -- required to disable caching of the current time parameter
	REGB_Temporal       = true, -- ensures reliability in Resolve 15
	REG_Unpredictable   = true,
})

local ConnectionLabel = [[
<table align="center" cellspacing="8">
  <tr>
    <td style="text-align: center;"></td>
    <td style="text-align: center; background-color: #051626; color: white; padding: 5px; font-weight: bold;">[ ]] ..
	FUSE_NAME .. [[ ]</td>
    <td style="text-align: center;">  →  [ vArrayShapeRender Custom Shape ]</td>
  </tr>
</table>
]]
function Create()
	-- [[ Creates the user interface. ]]
	InLabelConnect = self:AddInput(ConnectionLabel, 'LabelConnect', {
		LINKID_DataType = 'Text',
		INPID_InputControl = 'LabelControl',
		LBLC_MultiLine = true,
		INP_External = false,
		INP_Passive = true,
		IC_ControlPage = -1,
		IC_NoLabel = true,
		IC_NoReset = true,
	})
	InChanceOp = self:AddInput("Generate Random → ", "chanceOperation", {
		LINKID_DataType = "Number",
		INPID_InputControl = "ComboControl",
		IC_NoReset = true,
		INP_Default = 2,
		INP_Integer = true,
		{ CCS_AddString = "None" },
		--Lists
		{ CCS_AddString = "Pick from → input Array" },
		--Basics
		{ CCS_AddString = "Bool" },
		{ CCS_AddString = "Character" },
		{ CCS_AddString = "Word" },
		{ CCS_AddString = "Letter" },
		{ CCS_AddString = "Vowel" },
		--Names
		{ CCS_AddString = "Name" },
		{ CCS_AddString = "Male name" },
		{ CCS_AddString = "Male name w/last" },
		{ CCS_AddString = "Name w/last" },
		{ CCS_AddString = "Female name" },
		{ CCS_AddString = "Female name w/last" },
		--Numbers
		{ CCS_AddString = "Hash" },
		{ CCS_AddString = "Integer" },
		{ CCS_AddString = "Integer w/min" },
		{ CCS_AddString = "Integer w/both" },
		--Color
		{ CCS_AddString = "rgb" },
		{ CCS_AddString = "rgba" },
		{ CCS_AddString = "hsl " },
		{ CCS_AddString = "hsla" },
		--Tech
		{ CCS_AddString = "ip" },
		{ CCS_AddString = "ipv4" },
		{ CCS_AddString = "ipv6" },
		--location
		{ CCS_AddString = "Phone" },
		{ CCS_AddString = "Address" },
		{ CCS_AddString = "Street" },
		--Strings
		{ CCS_AddString = "String" },
		{ CCS_AddString = "Syllable" },
		{ CCS_AddString = "Shuffle" },
	})

	InArrayLength = self:AddInput("Array length", "arrayLength", {
		LINKID_DataType = "Number",
		INPID_InputControl = "ScrewControl",
		INP_MinScale = 1,
		INP_MaxScale = 100,
		INP_Default = 1,
		INP_MinAllowed = 1,
		INP_MaxAllowed = 1e+38,
		INP_Integer = true,
		LINK_Main = 1,
	})
	InSeed = self:AddInput("Seed", "seed", {
		LINKID_DataType = "Number",
		INPID_InputControl = "ScrewControl",
		INP_MinScale = -100,
		INP_MaxScale = 100,
		INP_Default = 0,
		INP_MinAllowed = -1e+38,
		INP_MaxAllowed = 1e+38,
	})
	InEmptySpace2 = self:AddInput('    ', 'EmptySpace2', {
		LINKID_DataType = 'Text',
		INPID_InputControl = 'LabelControl',
		ICD_Width = 0.3,
		INP_External = false,
		INP_Passive = true,
		IC_NoLabel = true,
		IC_NoReset = true,
	})
	self:BeginControlNest("Text Settings", "textsettings", false, {})
	InFont = self:AddInput("Font", "Font", {
		LINKID_DataType = "Text",
		INPID_InputControl = "FontFileControl",
		IC_ControlGroup = 2,
		IC_ControlID = 0,
		INP_Level = 1,
		INP_DoNotifyChanged = true,
	})

	InFontStyle = self:AddInput("Style", "Style", {
		LINKID_DataType = "Text",
		INPID_InputControl = "FontFileControl",
		IC_ControlGroup = 2,
		IC_ControlID = 1,
		INP_Level = 1,
		INP_DoNotifyChanged = true,
	})

	InSize = self:AddInput("Size", "Size", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_MinScale = 0.0,
		INP_MaxScale = 0.5,
		INP_Default = 0.08,
	})
	InCharacterSpacing = self:AddInput("Character Spacing", "Characterspacing", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_MinAllowed = -10,
		INP_MaxScale = 10.0,
		INP_Default = 0.0,
	})

	InCase = self:AddInput("Letter Case", "Case", {
		LINKID_DataType = "Number",
		INPID_InputControl = "MultiButtonControl",
		INP_Default = 0.0,
		{ MBTNC_AddButton = "NONE",  MBTNCD_ButtonWidth = 1 / 3, },
		{ MBTNC_AddButton = "UPPER", MBTNCD_ButtonWidth = 1 / 3, },
		{ MBTNC_AddButton = "LOWER", MBTNCD_ButtonWidth = 1 / 3, },
		INP_Integer = true,
	})

	InJustify = self:AddInput("Justification", "Justification", {
		LINKID_DataType = "Number",
		INPID_InputControl = "MultiButtonControl",
		INP_Default = 1.0,
		{ MBTNC_AddButton = "Left",   MBTNCD_ButtonWidth = 1 / 3, },
		{ MBTNC_AddButton = "Center", MBTNCD_ButtonWidth = 1 / 3, },
		{ MBTNC_AddButton = "Right",  MBTNCD_ButtonWidth = 1 / 3, },
		INP_Integer = true,
	})

	InHori_adjustment = self:AddInput("Horizontal Adjustment", "Hori_adjustment", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_MinScale = -0.5,
		INP_MaxScale = 0.5,
		INP_Default = 0.0,
		PC_ControlGroup = 1,
		PC_ControlID = 3,
	})
	InVer_adjustment = self:AddInput("Vertical Adjustment", "Ver_adjustment", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_MinScale = -0.5,
		INP_MaxScale = 0.5,
		INP_Default = 0.0,
		PC_ControlGroup = 1,
		PC_ControlID = 4,
	})
	InShowBackground = self:AddInput("Show Box Background", "ShowBackground", {
		LINKID_DataType = "Number",
		INPID_InputControl = "CheckboxControl",
		INP_Integer = true,
		INP_Default = 0.0,
		INP_External = false,
		INP_DoNotifyChanged = true
	})
	InBox_padding = self:AddInput("Box Padding", "Box_padding", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_MinScale = 0.0,
		INP_MaxScale = 1.0,
		INP_Default = 0.5,
	})
	InBox_adjustment = self:AddInput("Box Vertical Adjustment", "Box_Ver_adjustment", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_MinScale = 0.0,
		INP_MaxScale = 0.5,
		INP_Default = 0.0,
	})
	InBox_roundCorners = self:AddInput("Box Round Corners", "Box_roundCorners", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_MinScale = 0.0,
		INP_MaxScale = 0.1,
		INP_Default = 0.01,

	})
	self:EndControlNest()
	InShowInput = self:AddInput("Show Input", "ShowInput", {
		LINKID_DataType = "Number",
		INPID_InputControl = "CheckboxControl",
		INP_Integer = true,
		INP_Default = 1.0,
		INP_External = false,
		INP_DoNotifyChanged = true
	})
	InScriptValText = self:AddInput("ScriptVal Text", "ScriptValtext", {
		LINKID_DataType = "ScriptVal",
		LINK_Main = 1,
	})

	OutScriptValShape = self:AddOutput("OutputValShape", "OutputValShape", {
		LINKID_DataType = DATATYPE,
		LINK_Main = 1
	})
	OutScriptValData = self:AddOutput("OutputValData", "OutputValData", {
		LINKID_DataType = DATATYPE,
		LINK_Main = 2
	})
end

-- Custom utf8.offset function
function utf8_offset(s, n)
	local pos = 1
	for i = 1, n - 1 do
		pos = pos + utf8_charbytes(s, pos)
	end
	return pos
end

-- Custom utf8.charbytes function
function utf8_charbytes(s, i)
	local c = string.byte(s, i)
	if c > 0 and c <= 127 then
		return 1
	elseif c >= 194 and c <= 223 then
		return 2
	elseif c >= 224 and c <= 239 then
		return 3
	elseif c >= 240 and c <= 244 then
		return 4
	end
end

-- Custom utf8.codepoint function
function utf8_codepoint(s, i)
	local c = string.byte(s, i)
	if c <= 127 then
		return c
	elseif c >= 194 and c <= 223 then
		local c2 = string.byte(s, i + 1)
		return (c - 192) * 64 + (c2 - 128)
	elseif c >= 224 and c <= 239 then
		local c2 = string.byte(s, i + 1)
		local c3 = string.byte(s, i + 2)
		return (c - 224) * 4096 + (c2 - 128) * 64 + (c3 - 128)
	elseif c >= 240 and c <= 244 then
		local c2 = string.byte(s, i + 1)
		local c3 = string.byte(s, i + 2)
		local c4 = string.byte(s, i + 3)
		return (c - 240) * 262144 + (c2 - 128) * 4096 + (c3 - 128) * 64 + (c4 - 128)
	end
end

function createTextOptimized(text, align, fontsize, _font, _style, char_spacing, hori_adjustment, ver_adjustment,
							 box_padding, box_adjustment, roundCorners, background)
	local fontMetrics = TextStyleFont(_font, _style)
	local tfm = TextStyleFontMetrics(fontMetrics)

	local size = fontsize
	local line_height = (tfm.TextAscent + tfm.TextDescent + tfm.TextExternalLeading) * 10 * size
	local mat = Matrix4()
	mat:Scale((1.0 / tfm.Scale) * size, (1.0 / tfm.Scale) * size, 1.0)

	local shape = Shape()
	local shapeBase = Shape()
	local minX, minY, maxX, maxY = math.huge, math.huge, -math.huge, -math.huge
	local function applyJustification(mat, justify, line_width)
		if justify == 1 then
			mat:Move(-line_width / 2, 0, 0)
		elseif justify == 2 then
			mat:Move(-line_width, 0, 0)
		end
	end

	local total_height = 0

	local function updateBounds(point)
		if point.x < minX then minX = point.x end
		if point.y < minY then minY = point.y end
		if point.x > maxX then maxX = point.x end
		if point.y > maxY then maxY = point.y end
	end
	for line in string.gmatch(text, "[^\r\n]+") do
		local line_height_adjusted = line_height
		total_height = total_height + line_height_adjusted
	end

	local vertical_offset = ((total_height / 2) - ((tfm.TextAscent + tfm.TextDescent) * size / 2)) / 4
	--mat:Move(0, vertical_offset, 0)
	mat:Move(0, 0, 0)

	-- split the text into separate lines
	for line in string.gmatch(text, "[^\r\n]+") do
		local charWidths = {}
		local line_width = 0
		for i = 1, utf8.len(line) do
			local ch = utf8_codepoint(line, utf8_offset(line, i)) or utf8_codepoint(" ")
			charWidths[i] = tfm:CharacterWidth(ch) * (10 + char_spacing) * size
			line_width = line_width + charWidths[i]
		end

		applyJustification(mat, align, line_width)

		local x_move = 0
		local prevch = nil
		-- Second pass, now assemble the actual shape
		for i = 1, utf8.len(line) do
			local ch = utf8_codepoint(line, utf8_offset(line, i)) or utf8_codepoint(" ")
			local cw = charWidths[i]

			if prevch then
				local kerning = tfm:CharacterKerning(prevch, ch) * (10 + char_spacing) * size
				x_move = x_move + kerning
				mat:Move(kerning, 0.0, 0)
			end

			mat:Move(cw / 2, 0, 0)

			if ch ~= 32 then
				local sh = tfm:GetCharacterShape(ch, false):TransformOfShape(mat)
				shape:AddShape(sh)
				local transformedPoint = Vector4(0, 0, 0, 1) * mat
				updateBounds(transformedPoint)
			end

			mat:Move(cw / 2, 0.0, 0)
			x_move = x_move + cw
			prevch = ch
		end
		mat:Move(-x_move * (align == 1 and 0.5 or (align == 2 and 1 or 0)), -line_height, 0)
	end

	local padding = box_padding * size
	local rect = Shape()
	local shapeTable = {}
	if background == 1 then
		rect:AddRectangle(minX - padding, maxX + padding, minY - padding, maxY + padding, roundCorners, 8)
	else
	end
	local _height = (-(maxY + padding) / 2) + box_adjustment

	mat:Identity()
	mat:Move(0, _height, 0)
	mat:Move(hori_adjustment, ver_adjustment, 0)
	shape = shape:TransformOfShape(mat)

	mat:Identity()
	mat:Move(0, 0, 0)
	rect = rect:TransformOfShape(mat)
	shapeTable = { rect, shape }

	return shapeTable
end

function Process(req)
	local font           = InFont:GetValue(req).Value
	local style          = InFontStyle:GetValue(req).Value
	local text           = InScriptValText:GetValue(req):GetValue() or {}
	local size           = InSize:GetValue(req).Value
	local justify        = InJustify:GetValue(req).Value
	local hori_adjust    = InHori_adjustment:GetValue(req).Value
	local ver_adjust     = InVer_adjustment:GetValue(req).Value
	local box_padding    = InBox_padding:GetValue(req).Value
	local box_adjustment = InBox_adjustment:GetValue(req).Value
	local roundCorners   = InBox_roundCorners:GetValue(req).Value
	local char_spacing   = InCharacterSpacing:GetValue(req).Value
	local arrLength      = InArrayLength:GetValue(req).Value
	local result         = {}
	local seed           = InSeed:GetValue(req).Value
	local mode           = InChanceOp:GetValue(req).Value
	local outputShape    = {}
	local outputData     = {}

	if not next(FontManager:GetFontList()) then
		FontManager:ScanDir()
	end

	if req:IsQuick() then
		quality = 1
	end

	-- Seed the random number generator
	chance:seed(seed)
	-- Helper function to capitalize the first letter
	local function firstToUpper(str)
		return str:sub(1, 1):upper() .. str:sub(2)
	end

	-- Generate random values based on the selected mode
	local function generateRandomValue(mode)
		if mode == 0 then
			return nil
		elseif mode == 1 then
			return tostring(chance:pick(text))
		elseif mode == 2 then
			return firstToUpper(tostring(chance:bool()))
		elseif mode == 3 then
			return tostring(chance:character())
		elseif mode == 4 then
			return tostring(firstToUpper(chance:word()))
		elseif mode == 5 then
			return tostring(chance:letter())
		elseif mode == 6 then
			return tostring(chance:vowel())
		elseif mode == 7 then
			return tostring(chance:name())
		elseif mode == 8 then
			return tostring(chance:name(true))
		elseif mode == 9 then
			return tostring(chance:male())
		elseif mode == 10 then
			return tostring(chance:male(true))
		elseif mode == 11 then
			return tostring(chance:female())
		elseif mode == 12 then
			return tostring(chance:female(true))
		elseif mode == 13 then
			return tostring(chance:hash())
		elseif mode == 14 then
			return tostring(chance:integer())
		elseif mode == 15 then
			return tostring(chance:integer(500))
		elseif mode == 16 then
			return tostring(chance:integer(-500, 500))
		elseif mode == 17 then
			local r, g, b = chance:rgb()
			return tostring(r .. "," .. g .. "," .. b)
		elseif mode == 18 then
			local r, g, b, a = chance:rgba()
			return tostring(r .. "," .. g .. "," .. b .. "," .. a)
		elseif mode == 19 then
			local h, s, l = chance:hsl()
			return tostring(h .. "," .. s .. "," .. l)
		elseif mode == 20 then
			local h, s, l, a = chance:hsla()
			return tostring(h .. "," .. s .. "," .. l .. "," .. a)
		elseif mode == 21 then
			return tostring(chance:ip())
		elseif mode == 22 then
			return tostring(chance:ipv4())
		elseif mode == 23 then
			return tostring(chance:ipv6())
		elseif mode == 24 then
			return tostring(chance:phone())
		elseif mode == 25 then
			return tostring(chance:address())
		elseif mode == 26 then
			return tostring(chance:street())
		elseif mode == 27 then
			return tostring(firstToUpper(chance:string(math.random(3, 10))))
		elseif mode == 28 then
			return tostring(chance:syllable())
		elseif mode == 29 then
			return tostring(table.unpack(chance:shuffle({ "A", "B", "C", "D", "E", "F", "GH", "", "I", "J", "K", "L", "M",
				"N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h",
				"i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2",
				"3", "4", "5", "6", "7", "8", "9"
			})))
		end
	end

	if mode == 0 then
		--clear the table
		for k, _ in pairs(result) do result[k] = nil end
	else
		-- Generate random values based on the selected mode
		for i = 1, arrLength do
			table.insert(result, i, generateRandomValue(mode))
		end
	end

	-- Upper and Lowercase
	local case = InCase:GetValue(req).Value
	local modified_text


	for i = 1, #result do
		modified_text = result[i]
		if case == 0 then
			modified_text = result[i]
		elseif case == 1 then
			modified_text = utf8.upper(result[i])
		elseif case == 2 then
			modified_text = utf8.lower(result[i])
		end

		table.insert(outputData, i, modified_text)
		table.insert(outputShape, i,
			createTextOptimized(modified_text, justify, size, font, style, char_spacing, hori_adjust, ver_adjust,
				box_padding, box_adjustment, roundCorners, InShowBackground:GetValue(req).Value))
	end

	OutScriptValShape:Set(req, ScriptValParam(outputShape))
	OutScriptValData:Set(req, ScriptValParam(outputData))
end

function NotifyChanged(inp, param, time)
	-- when the tools FontFileControl is first created, the FontManager has not yet
	-- provided a FontList, so we can't set a default value. Instead we do it here.
	if inp == InFont then
		local f = param.Value

		if f == nil or string.len(f) == 0 then
			InFont:SetSource(Text("Open Sans"), time)
		end
	elseif inp == InFontStyle then
		local f = param.Value

		if f == nil or string.len(f) == 0 then
			InFontStyle:SetSource(Text("Regular"), time)
		end
	end

	if inp == InShowInput then
		if param.Value == 1.0 then visible = true else visible = false end
	end
	local bg_visible
	if inp == InShowBackground then
		if param.Value == 1.0 then bg_visible = true else bg_visible = false end

		InBox_padding:SetAttrs({ IC_Visible = bg_visible, PC_Visible = bg_visible })
		InBox_adjustment:SetAttrs({ IC_Visible = bg_visible, PC_Visible = bg_visible })
		InBox_roundCorners:SetAttrs({ IC_Visible = bg_visible, PC_Visible = bg_visible })
	end
end

